{"mappings":"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","sources":["node_modules/.pnpm/@parcel+runtime-js@2.1.0_@parcel+core@2.1.0/node_modules/@parcel/runtime-js/lib/helpers/bundle-manifest.js","node_modules/.pnpm/@parcel+runtime-js@2.1.0_@parcel+core@2.1.0/node_modules/@parcel/runtime-js/lib/helpers/bundle-url.js","node_modules/.pnpm/@parcel+runtime-js@2.1.0_@parcel+core@2.1.0/node_modules/@parcel/runtime-js/lib/runtime-d9b0599a83fb37e3.js","node_modules/.pnpm/nanoevents@6.0.2/node_modules/nanoevents/index.js","node_modules/.pnpm/@logux+core@0.7.2/node_modules/@logux/core/log/index.js","node_modules/.pnpm/@logux+core@0.7.2/node_modules/@logux/core/is-first-older/index.js","node_modules/.pnpm/@logux+core@0.7.2/node_modules/@logux/core/ws-connection/index.js","node_modules/.pnpm/@logux+core@0.7.2/node_modules/@logux/core/memory-store/index.js","node_modules/.pnpm/@logux+core@0.7.2/node_modules/@logux/core/logux-error/index.js","node_modules/.pnpm/@logux+core@0.7.2/node_modules/@logux/core/connect/index.js","node_modules/.pnpm/@logux+core@0.7.2/node_modules/@logux/core/base-node/index.js","node_modules/.pnpm/@logux+core@0.7.2/node_modules/@logux/core/sync/index.js","node_modules/.pnpm/@logux+core@0.7.2/node_modules/@logux/core/ping/index.js","node_modules/.pnpm/@logux+core@0.7.2/node_modules/@logux/core/debug/index.js","node_modules/.pnpm/@logux+core@0.7.2/node_modules/@logux/core/error/index.js","node_modules/.pnpm/@logux+core@0.7.2/node_modules/@logux/core/headers/index.js","node_modules/.pnpm/@logux+core@0.7.2/node_modules/@logux/core/client-node/index.js","node_modules/.pnpm/@logux+core@0.7.2/node_modules/@logux/core/local-pair/index.js","node_modules/.pnpm/@logux+core@0.7.2/node_modules/@logux/core/reconnect/index.js","node_modules/.pnpm/@logux+core@0.7.2/node_modules/@logux/core/parse-id/index.js","status/index.js","badge/index.js","node_modules/.pnpm/nanoid@3.1.30/node_modules/nanoid/index.browser.js","logux-undo-error/index.js","client/index.js","cross-tab-client/index.js","confirm/index.js","log/index.js","node_modules/.pnpm/@parcel+runtime-js@2.1.0_@parcel+core@2.1.0/node_modules/@parcel/runtime-js/lib/runtime-18a80722263abb40.js","node_modules/.pnpm/@parcel+runtime-js@2.1.0_@parcel+core@2.1.0/node_modules/@parcel/runtime-js/lib/runtime-f64835876505b6b9.js","node_modules/.pnpm/@parcel+runtime-js@2.1.0_@parcel+core@2.1.0/node_modules/@parcel/runtime-js/lib/runtime-60495cde73d05c63.js","node_modules/.pnpm/@parcel+runtime-js@2.1.0_@parcel+core@2.1.0/node_modules/@parcel/runtime-js/lib/runtime-be2a04576e5243bd.js","badge/styles/index.js","node_modules/.pnpm/@parcel+runtime-js@2.1.0_@parcel+core@2.1.0/node_modules/@parcel/runtime-js/lib/runtime-7b0027d6a3ec6988.js","node_modules/.pnpm/@parcel+runtime-js@2.1.0_@parcel+core@2.1.0/node_modules/@parcel/runtime-js/lib/runtime-a3107fd2ac196098.js","node_modules/.pnpm/@parcel+runtime-js@2.1.0_@parcel+core@2.1.0/node_modules/@parcel/runtime-js/lib/runtime-1171cbd6a91fdf93.js","test/demo/index.js","track/index.js","attention/index.js","favicon/index.js"],"sourcesContent":["\"use strict\";\n\nvar mapping = {};\n\nfunction register(pairs) {\n  var keys = Object.keys(pairs);\n\n  for (var i = 0; i < keys.length; i++) {\n    mapping[keys[i]] = pairs[keys[i]];\n  }\n}\n\nfunction resolve(id) {\n  var resolved = mapping[id];\n\n  if (resolved == null) {\n    throw new Error('Could not resolve bundle with id ' + id);\n  }\n\n  return resolved;\n}\n\nmodule.exports.register = register;\nmodule.exports.resolve = resolve;","\"use strict\";\n\nvar bundleURL = {};\n\nfunction getBundleURLCached(id) {\n  var value = bundleURL[id];\n\n  if (!value) {\n    value = getBundleURL();\n    bundleURL[id] = value;\n  }\n\n  return value;\n}\n\nfunction getBundleURL() {\n  try {\n    throw new Error();\n  } catch (err) {\n    var matches = ('' + err.stack).match(/(https?|file|ftp):\\/\\/[^)\\n]+/g);\n\n    if (matches) {\n      // The first two stack frames will be this function and getBundleURLCached.\n      // Use the 3rd one, which will be a runtime in the original bundle.\n      return getBaseURL(matches[2]);\n    }\n  }\n\n  return '/';\n}\n\nfunction getBaseURL(url) {\n  return ('' + url).replace(/^((?:https?|file|ftp):\\/\\/.+)\\/[^/]+$/, '$1') + '/';\n} // TODO: Replace uses with `new URL(url).origin` when ie11 is no longer supported.\n\n\nfunction getOrigin(url) {\n  var matches = ('' + url).match(/(https?|file|ftp):\\/\\/[^/]+/);\n\n  if (!matches) {\n    throw new Error('Origin not found');\n  }\n\n  return matches[0];\n}\n\nexports.getBundleURL = getBundleURLCached;\nexports.getBaseURL = getBaseURL;\nexports.getOrigin = getOrigin;","require('./helpers/bundle-manifest').register(JSON.parse(\"{\\\"jGf7V\\\":\\\"index.dcbf1025.js\\\",\\\"9KQjq\\\":\\\"refresh.f7f11930.svg\\\",\\\"dVjUq\\\":\\\"success.5585cf5f.svg\\\",\\\"gWDF8\\\":\\\"offline.c7da2f9d.svg\\\",\\\"6EP5R\\\":\\\"error.8319e405.svg\\\",\\\"d2JJm\\\":\\\"offline.203f1963.png\\\",\\\"2YULu\\\":\\\"normal.60452f34.png\\\",\\\"ht41N\\\":\\\"error.a2ca88ad.png\\\"}\"));","export let createNanoEvents = () => ({\n  events: {},\n  emit(event, ...args) {\n    ;(this.events[event] || []).forEach(i => i(...args))\n  },\n  on(event, cb) {\n    ;(this.events[event] = this.events[event] || []).push(cb)\n    return () =>\n      (this.events[event] = (this.events[event] || []).filter(i => i !== cb))\n  }\n})\n","import { createNanoEvents } from 'nanoevents'\n\nexport function actionEvents(emitter, event, action, meta) {\n  if (action.id) {\n    emitter.emit(`${event}-${action.type}-${action.id}`, action, meta)\n  }\n  emitter.emit(`${event}-${action.type}-`, action, meta)\n  emitter.emit(event, action, meta)\n}\n\nexport class Log {\n  constructor(opts = {}) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof opts.nodeId === 'undefined') {\n        throw new Error('Expected node ID')\n      }\n      if (typeof opts.store !== 'object') {\n        throw new Error('Expected store')\n      }\n      if (opts.nodeId.includes(' ')) {\n        throw new Error('Space is prohibited in node ID')\n      }\n    }\n\n    this.nodeId = opts.nodeId\n\n    this.lastTime = 0\n    this.sequence = 0\n\n    this.store = opts.store\n\n    this.emitter = createNanoEvents()\n  }\n\n  on(event, listener) {\n    return this.emitter.on(event, listener)\n  }\n\n  type(type, listener, opts = {}) {\n    let event = opts.event || 'add'\n    let id = opts.id || ''\n    return this.emitter.on(`${event}-${type}-${id}`, listener)\n  }\n\n  async add(action, meta = {}) {\n    if (typeof action.type === 'undefined') {\n      throw new Error('Expected \"type\" in action')\n    }\n\n    let newId = false\n    if (typeof meta.id === 'undefined') {\n      newId = true\n      meta.id = this.generateId()\n    }\n\n    if (typeof meta.time === 'undefined') {\n      meta.time = parseInt(meta.id)\n    }\n\n    if (typeof meta.reasons === 'undefined') {\n      meta.reasons = []\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (!Array.isArray(meta.reasons)) {\n        throw new Error('Expected \"reasons\" to be an array of strings')\n      }\n\n      for (let reason of meta.reasons) {\n        if (typeof reason !== 'string') {\n          throw new Error('Expected \"reasons\" to be an array of strings')\n        }\n      }\n\n      if (typeof meta.indexes !== 'undefined') {\n        if (!Array.isArray(meta.indexes)) {\n          throw new Error('Expected \"indexes\" to be an array of strings')\n        }\n\n        for (let index of meta.indexes) {\n          if (typeof index !== 'string') {\n            throw new Error('Expected \"indexes\" to be an array of strings')\n          }\n        }\n      }\n    }\n\n    actionEvents(this.emitter, 'preadd', action, meta)\n\n    if (meta.keepLast) {\n      this.removeReason(meta.keepLast, { olderThan: meta })\n      meta.reasons.push(meta.keepLast)\n    }\n\n    if (meta.reasons.length === 0 && newId) {\n      actionEvents(this.emitter, 'add', action, meta)\n      actionEvents(this.emitter, 'clean', action, meta)\n      return meta\n    } else if (meta.reasons.length === 0) {\n      let [action2] = await this.store.byId(meta.id)\n      if (action2) {\n        return false\n      } else {\n        actionEvents(this.emitter, 'add', action, meta)\n        actionEvents(this.emitter, 'clean', action, meta)\n        return meta\n      }\n    } else {\n      let addedMeta = await this.store.add(action, meta)\n      if (addedMeta === false) {\n        return false\n      } else {\n        actionEvents(this.emitter, 'add', action, meta)\n        return addedMeta\n      }\n    }\n  }\n\n  generateId() {\n    let now = Date.now()\n    if (now <= this.lastTime) {\n      now = this.lastTime\n      this.sequence += 1\n    } else {\n      this.lastTime = now\n      this.sequence = 0\n    }\n    return now + ' ' + this.nodeId + ' ' + this.sequence\n  }\n\n  each(opts, callback) {\n    if (!callback) {\n      callback = opts\n      opts = { order: 'created' }\n    }\n\n    let store = this.store\n    return new Promise(resolve => {\n      async function nextPage(get) {\n        let page = await get()\n        let result\n        for (let i = page.entries.length - 1; i >= 0; i--) {\n          let entry = page.entries[i]\n          result = callback(entry[0], entry[1])\n          if (result === false) break\n        }\n\n        if (result === false || !page.next) {\n          resolve()\n        } else {\n          nextPage(page.next)\n        }\n      }\n\n      nextPage(store.get.bind(store, opts))\n    })\n  }\n\n  async changeMeta(id, diff) {\n    for (let k in diff) {\n      if (\n        k === 'id' ||\n        k === 'added' ||\n        k === 'time' ||\n        k === 'subprotocol' ||\n        k === 'indexes'\n      ) {\n        throw new Error('Meta \"' + k + '\" is read-only')\n      }\n    }\n\n    if (diff.reasons && diff.reasons.length === 0) {\n      let entry = await this.store.remove(id)\n      if (entry) {\n        for (let k in diff) entry[1][k] = diff[k]\n        actionEvents(this.emitter, 'clean', entry[0], entry[1])\n      }\n      return !!entry\n    } else {\n      return this.store.changeMeta(id, diff)\n    }\n  }\n\n  removeReason(reason, criteria = {}) {\n    return this.store.removeReason(reason, criteria, (action, meta) => {\n      actionEvents(this.emitter, 'clean', action, meta)\n    })\n  }\n\n  byId(id) {\n    return this.store.byId(id)\n  }\n}\n","export function isFirstOlder(firstMeta, secondMeta) {\n  if (firstMeta && !secondMeta) {\n    return false\n  } else if (!firstMeta && secondMeta) {\n    return true\n  }\n\n  if (firstMeta.time > secondMeta.time) {\n    return false\n  } else if (firstMeta.time < secondMeta.time) {\n    return true\n  }\n\n  let first = firstMeta.id.split(' ')\n  let second = secondMeta.id.split(' ')\n\n  let firstNode = first[1]\n  let secondNode = second[1]\n  if (firstNode > secondNode) {\n    return false\n  } else if (firstNode < secondNode) {\n    return true\n  }\n\n  let firstCounter = parseInt(first[2])\n  let secondCounter = parseInt(second[2])\n  if (firstCounter > secondCounter) {\n    return false\n  } else if (firstCounter < secondCounter) {\n    return true\n  }\n\n  let firstNodeTime = parseInt(first[0])\n  let secondNodeTime = parseInt(second[0])\n  if (firstNodeTime > secondNodeTime) {\n    return false\n  } else if (firstNodeTime < secondNodeTime) {\n    return true\n  }\n\n  return false\n}\n","import { createNanoEvents } from 'nanoevents'\n\nexport class WsConnection {\n  constructor(url, Class, opts) {\n    this.connected = false\n    this.emitter = createNanoEvents()\n    if (Class) {\n      this.Class = Class\n    } else if (typeof WebSocket !== 'undefined') {\n      this.Class = WebSocket\n    } else {\n      throw new Error('No WebSocket support')\n    }\n    this.url = url\n    this.opts = opts\n  }\n\n  init(ws) {\n    ws.onerror = event => {\n      this.emitter.emit('error', event.error || new Error('WS Error'))\n    }\n\n    ws.onclose = () => {\n      this.onclose()\n    }\n\n    ws.onmessage = event => {\n      let data\n      try {\n        data = JSON.parse(event.data)\n      } catch {\n        this.error(event.data)\n        return\n      }\n      this.emitter.emit('message', data)\n    }\n\n    this.ws = ws\n  }\n\n  connect() {\n    if (this.ws) return Promise.resolve()\n\n    this.emitter.emit('connecting')\n    this.init(new this.Class(this.url, undefined, this.opts))\n\n    return new Promise(resolve => {\n      this.ws.onopen = () => {\n        this.connected = true\n        this.emitter.emit('connect')\n        resolve()\n      }\n    })\n  }\n\n  disconnect() {\n    if (this.ws) {\n      this.ws.onclose = undefined\n      this.ws.close()\n      this.onclose()\n    }\n  }\n\n  on(event, listener) {\n    return this.emitter.on(event, listener)\n  }\n\n  send(message) {\n    if (this.ws && this.ws.readyState === this.ws.OPEN) {\n      this.ws.send(JSON.stringify(message))\n    } else {\n      this.emitter.emit('error', new Error('WS was closed'))\n    }\n  }\n\n  error(message) {\n    let err = new Error('Wrong message format')\n    err.received = message\n    this.emitter.emit('error', err)\n  }\n\n  onclose() {\n    if (this.ws) {\n      this.connected = false\n      this.emitter.emit('disconnect')\n      this.ws = undefined\n    }\n  }\n}\n","import { isFirstOlder } from '../is-first-older/index.js'\n\nfunction checkIndex(store, index) {\n  if (!store.indexes[index]) {\n    store.indexes[index] = { added: [], entries: [] }\n  }\n}\n\nfunction forEachIndex(meta, cb) {\n  let indexes = meta.indexes\n  if (isDefined(indexes) && indexes.length > 0) {\n    for (let index of indexes) {\n      cb(index)\n    }\n  }\n}\n\nfunction insert(store, entry) {\n  store.lastAdded += 1\n  entry[1].added = store.lastAdded\n  store.added.push(entry)\n  forEachIndex(entry[1], index => {\n    checkIndex(store, index)\n    store.indexes[index].added.push(entry)\n  })\n  return Promise.resolve(entry[1])\n}\n\nfunction eject(store, meta) {\n  let added = meta.added\n  let start = 0\n  let end = store.added.length - 1\n  while (start <= end) {\n    let middle = (end + start) >> 1\n    let otherAdded = store.added[middle][1].added\n    if (otherAdded < added) {\n      start = middle + 1\n    } else if (otherAdded > added) {\n      end = middle - 1\n    } else {\n      store.added.splice(middle, 1)\n      break\n    }\n  }\n}\n\nfunction find(list, id) {\n  for (let i = list.length - 1; i >= 0; i--) {\n    if (id === list[i][1].id) {\n      return i\n    }\n  }\n  return -1\n}\n\nfunction isDefined(value) {\n  return typeof value !== 'undefined'\n}\n\nexport class MemoryStore {\n  constructor() {\n    this.entries = []\n    this.added = []\n    this.indexes = {}\n    this.lastReceived = 0\n    this.lastAdded = 0\n    this.lastSent = 0\n  }\n\n  async add(action, meta) {\n    let entry = [action, meta]\n    let id = meta.id\n\n    let list = this.entries\n    for (let i = 0; i < list.length; i++) {\n      let [, otherMeta] = list[i]\n      if (id === otherMeta.id) {\n        return false\n      } else if (!isFirstOlder(otherMeta, meta)) {\n        forEachIndex(meta, index => {\n          checkIndex(this, index)\n          let indexList = this.indexes[index].entries\n          let j = indexList.findIndex(item => !isFirstOlder(item[1], meta))\n          indexList.splice(j, 0, entry)\n        })\n        list.splice(i, 0, entry)\n        return insert(this, entry)\n      }\n    }\n\n    forEachIndex(meta, index => {\n      checkIndex(this, index)\n      this.indexes[index].entries.push(entry)\n    })\n    list.push(entry)\n    return insert(this, entry)\n  }\n\n  async byId(id) {\n    let created = find(this.entries, id)\n    if (created === -1) {\n      return [null, null]\n    } else {\n      let [action, meta] = this.entries[created]\n      return [action, meta]\n    }\n  }\n\n  async remove(id, created) {\n    if (typeof created === 'undefined') {\n      created = find(this.entries, id)\n      if (created === -1) return Promise.resolve(false)\n    }\n\n    let entry = [this.entries[created][0], this.entries[created][1]]\n    forEachIndex(entry[1], index => {\n      let entries = this.indexes[index].entries\n      let indexed = find(entries, id)\n      if (indexed !== -1) entries.splice(indexed, 1)\n    })\n    this.entries.splice(created, 1)\n\n    forEachIndex(entry[1], index => {\n      eject(this.indexes[index], entry[1])\n    })\n    eject(this, entry[1])\n\n    return entry\n  }\n\n  async get(opts = {}) {\n    let index = opts.index\n    let store = this\n    let entries\n    if (index) {\n      store = this.indexes[index] || { added: [], entries: [] }\n    }\n    if (opts.order === 'created') {\n      entries = store.entries\n    } else {\n      entries = store.added\n    }\n    return { entries: entries.slice(0) }\n  }\n\n  async changeMeta(id, diff) {\n    let index = find(this.entries, id)\n    if (index === -1) {\n      return false\n    } else {\n      let meta = this.entries[index][1]\n      for (let key in diff) meta[key] = diff[key]\n      return true\n    }\n  }\n\n  async removeReason(reason, criteria, callback) {\n    let removed = []\n\n    if (criteria.id) {\n      let index = find(this.entries, criteria.id)\n      if (index !== -1) {\n        let meta = this.entries[index][1]\n        let reasonPos = meta.reasons.indexOf(reason)\n        if (reasonPos !== -1) {\n          meta.reasons.splice(reasonPos, 1)\n          if (meta.reasons.length === 0) {\n            callback(this.entries[index][0], meta)\n            this.remove(criteria.id)\n          }\n        }\n      }\n    } else {\n      this.entries = this.entries.filter(([action, meta]) => {\n        let c = criteria\n\n        let reasonPos = meta.reasons.indexOf(reason)\n        if (reasonPos === -1) {\n          return true\n        }\n        if (isDefined(c.olderThan) && !isFirstOlder(meta, c.olderThan)) {\n          return true\n        }\n        if (isDefined(c.youngerThan) && !isFirstOlder(c.youngerThan, meta)) {\n          return true\n        }\n        if (isDefined(c.minAdded) && meta.added < c.minAdded) {\n          return true\n        }\n        if (isDefined(c.maxAdded) && meta.added > c.maxAdded) {\n          return true\n        }\n\n        meta.reasons.splice(reasonPos, 1)\n        if (meta.reasons.length === 0) {\n          callback(action, meta)\n          removed.push(meta)\n          return false\n        } else {\n          return true\n        }\n      })\n\n      let removedAdded = removed.map(m => m.added)\n      let removing = i => !removedAdded.includes(i[1].added)\n      this.added = this.added.filter(removing)\n\n      for (let meta of removed) {\n        forEachIndex(meta, i => {\n          this.indexes[i].entries = this.indexes[i].entries.filter(removing)\n          this.indexes[i].added = this.indexes[i].added.filter(removing)\n        })\n      }\n    }\n  }\n\n  async clean() {\n    this.entries = []\n    this.added = []\n    this.indexes = {}\n    this.lastReceived = 0\n    this.lastAdded = 0\n    this.lastSent = 0\n  }\n\n  async getLastAdded() {\n    return this.lastAdded\n  }\n\n  async getLastSynced() {\n    return {\n      received: this.lastReceived,\n      sent: this.lastSent\n    }\n  }\n\n  async setLastSynced(values) {\n    if (typeof values.sent !== 'undefined') {\n      this.lastSent = values.sent\n    }\n    if (typeof values.received !== 'undefined') {\n      this.lastReceived = values.received\n    }\n  }\n}\n","export class LoguxError extends Error {\n  static describe(type, options) {\n    if (type === 'timeout') {\n      return 'A timeout was reached (' + options + ' ms)'\n    } else if (type === 'wrong-format') {\n      return 'Wrong message format in ' + options\n    } else if (type === 'unknown-message') {\n      return 'Unknown message `' + options + '` type'\n    } else if (type === 'bruteforce') {\n      return 'Too many wrong authentication attempts'\n    } else if (type === 'wrong-protocol') {\n      return (\n        `Logux supports protocols only from version ${options.supported}` +\n        `, but you use ${options.used}`\n      )\n    } else if (type === 'wrong-subprotocol') {\n      return (\n        `Only ${options.supported} application subprotocols are ` +\n        `supported, but you use ${options.used}`\n      )\n    } else if (type === 'wrong-credentials') {\n      return 'Wrong credentials'\n    } else {\n      return type\n    }\n  }\n\n  constructor(type, options, received) {\n    super(type)\n    this.name = 'LoguxError'\n    this.type = type\n    this.options = options\n    this.description = LoguxError.describe(type, options)\n    this.received = !!received\n\n    if (received) {\n      this.message = 'Logux received ' + this.type + ' error'\n      if (this.description !== this.type) {\n        this.message += ' (' + this.description + ')'\n      }\n    } else {\n      this.message = this.description\n    }\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, LoguxError)\n    }\n  }\n}\n","import { LoguxError } from '../logux-error/index.js'\n\nasync function auth(node, nodeId, token, callback) {\n  if (!node.options.auth) {\n    node.authenticated = true\n    callback()\n    return\n  }\n\n  try {\n    let access = await node.options.auth(nodeId, token, node.remoteHeaders)\n    if (access) {\n      node.authenticated = true\n      callback()\n      for (let i = 0; i < node.unauthenticated.length; i++) {\n        node.onMessage(node.unauthenticated[i])\n      }\n      node.unauthenticated = []\n    } else {\n      node.sendError(new LoguxError('wrong-credentials'))\n      node.destroy()\n    }\n  } catch (e) {\n    if (e.name === 'LoguxError') {\n      node.sendError(e)\n      node.destroy()\n    } else {\n      node.error(e)\n    }\n  }\n}\n\nfunction checkProtocol(node, ver) {\n  node.remoteProtocol = ver\n\n  if (ver >= node.minProtocol) {\n    return true\n  } else {\n    node.sendError(\n      new LoguxError('wrong-protocol', {\n        supported: node.minProtocol,\n        used: ver\n      })\n    )\n    node.destroy()\n    return false\n  }\n}\n\nfunction emitEvent(node) {\n  try {\n    node.emitter.emit('connect')\n  } catch (e) {\n    if (e.name === 'LoguxError') {\n      node.sendError(e)\n      return false\n    } else {\n      throw e\n    }\n  }\n  return true\n}\n\nexport async function sendConnect() {\n  let message = [\n    'connect',\n    this.localProtocol,\n    this.localNodeId,\n    this.lastReceived\n  ]\n\n  let options = {}\n  if (this.options.token) {\n    if (typeof this.options.token === 'function') {\n      options.token = await this.options.token()\n    } else {\n      options.token = this.options.token\n    }\n  }\n  if (this.options.subprotocol) {\n    options.subprotocol = this.options.subprotocol\n  }\n  if (Object.keys(options).length > 0) message.push(options)\n\n  if (this.options.fixTime) this.connectSended = this.now()\n\n  if (Object.keys(this.localHeaders).length > 0) {\n    this.sendHeaders(this.localHeaders)\n  }\n\n  this.startTimeout()\n  this.send(message)\n}\n\nexport async function sendConnected(start, end) {\n  let message = [\n    'connected',\n    this.localProtocol,\n    this.localNodeId,\n    [start, end]\n  ]\n\n  let options = {}\n  if (this.options.token) {\n    if (typeof this.options.token === 'function') {\n      options.token = await this.options.token()\n    } else {\n      options.token = this.options.token\n    }\n  }\n  if (this.options.subprotocol) {\n    options.subprotocol = this.options.subprotocol\n  }\n  if (Object.keys(options).length > 0) message.push(options)\n\n  if (Object.keys(this.localHeaders).length > 0) {\n    this.sendHeaders(this.localHeaders)\n  }\n\n  this.send(message)\n}\n\nexport function connectMessage(ver, nodeId, synced, options) {\n  let start = this.now()\n  if (!options) options = {}\n\n  this.remoteNodeId = nodeId\n  if (!checkProtocol(this, ver)) return\n\n  this.remoteSubprotocol = options.subprotocol || '0.0.0'\n\n  if (!emitEvent(this)) {\n    this.destroy()\n    return\n  }\n\n  auth(this, nodeId, options.token, () => {\n    this.baseTime = this.now()\n    this.sendConnected(start, this.baseTime)\n    this.syncSince(synced)\n  })\n}\n\nexport function connectedMessage(ver, nodeId, time, options) {\n  if (!options) options = {}\n\n  this.endTimeout()\n  this.remoteNodeId = nodeId\n  if (!checkProtocol(this, ver)) return\n\n  this.baseTime = time[1]\n\n  if (this.options.fixTime) {\n    let now = this.now()\n    let authTime = time[1] - time[0]\n    let roundTrip = now - this.connectSended - authTime\n    this.timeFix = Math.floor(this.connectSended - time[0] + roundTrip / 2)\n  }\n\n  this.remoteSubprotocol = options.subprotocol || '0.0.0'\n\n  if (!emitEvent(this)) {\n    this.destroy()\n    return\n  }\n\n  auth(this, nodeId, options.token, () => {\n    this.syncSince(this.lastSent)\n  })\n}\n","import { createNanoEvents } from 'nanoevents'\n\nimport {\n  sendConnect,\n  sendConnected,\n  connectMessage,\n  connectedMessage\n} from '../connect/index.js'\nimport {\n  syncedMessage,\n  syncMessage,\n  sendSynced,\n  sendSync\n} from '../sync/index.js'\nimport { sendPing, pingMessage, pongMessage } from '../ping/index.js'\nimport { sendHeaders, headersMessage } from '../headers/index.js'\nimport { sendDebug, debugMessage } from '../debug/index.js'\nimport { sendError, errorMessage } from '../error/index.js'\nimport { LoguxError } from '../logux-error/index.js'\n\nconst NOT_TO_THROW = {\n  'wrong-subprotocol': true,\n  'wrong-protocol': true,\n  'timeout': true\n}\n\nconst BEFORE_AUTH = ['connect', 'connected', 'error', 'debug', 'headers']\n\nasync function syncMappedEvent(node, action, meta) {\n  let added = meta.added\n  if (typeof added === 'undefined') {\n    let lastAdded = node.lastAddedCache\n    added = lastAdded > node.lastSent ? lastAdded : node.lastSent\n  }\n  if (node.options.outMap) {\n    try {\n      let changed = await node.options.outMap(action, meta)\n      node.sendSync(added, [changed])\n    } catch (e) {\n      node.error(e)\n    }\n  } else {\n    node.sendSync(added, [[action, meta]])\n  }\n}\n\nexport class BaseNode {\n  constructor(nodeId, log, connection, options = {}) {\n    this.remoteNodeId = undefined\n    this.remoteProtocol = undefined\n    this.remoteSubprotocol = undefined\n\n    this.minProtocol = 3\n    this.localProtocol = 4\n    this.localNodeId = nodeId\n\n    this.log = log\n    this.connection = connection\n    this.options = options\n\n    if (this.options.ping && !this.options.timeout) {\n      throw new Error('You must set timeout option to use ping')\n    }\n\n    this.connected = false\n    this.authenticated = false\n    this.unauthenticated = []\n\n    this.timeFix = 0\n    this.syncing = 0\n    this.received = {}\n\n    this.lastSent = 0\n    this.lastReceived = 0\n\n    this.state = 'disconnected'\n\n    this.emitter = createNanoEvents()\n    this.timeouts = []\n    this.throwsError = true\n\n    this.unbind = [\n      log.on('add', (action, meta) => {\n        this.onAdd(action, meta)\n      }),\n      connection.on('connecting', () => {\n        this.onConnecting()\n      }),\n      connection.on('connect', () => {\n        this.onConnect()\n      }),\n      connection.on('message', message => {\n        this.onMessage(message)\n      }),\n      connection.on('error', error => {\n        if (error.message === 'Wrong message format') {\n          this.sendError(new LoguxError('wrong-format', error.received))\n          this.connection.disconnect('error')\n        } else {\n          this.error(error)\n        }\n      }),\n      connection.on('disconnect', () => {\n        this.onDisconnect()\n      })\n    ]\n\n    this.initialized = false\n    this.lastAddedCache = 0\n    this.initializing = this.initialize()\n    this.localHeaders = {}\n    this.remoteHeaders = {}\n  }\n\n  on(event, listener) {\n    return this.emitter.on(event, listener)\n  }\n\n  catch(listener) {\n    this.throwsError = false\n    let unbind = this.on('error', listener)\n    return () => {\n      this.throwsError = true\n      unbind()\n    }\n  }\n\n  waitFor(state) {\n    if (this.state === state) {\n      return Promise.resolve()\n    }\n    return new Promise(resolve => {\n      let unbind = this.on('state', () => {\n        if (this.state === state) {\n          unbind()\n          resolve()\n        }\n      })\n    })\n  }\n\n  destroy() {\n    if (this.connection.destroy) {\n      this.connection.destroy()\n    } else if (this.connected) {\n      this.connection.disconnect('destroy')\n    }\n    for (let i of this.unbind) i()\n    clearTimeout(this.pingTimeout)\n    this.endTimeout()\n  }\n\n  setLocalHeaders(headers) {\n    this.localHeaders = headers\n    if (this.connected) {\n      this.sendHeaders(headers)\n    }\n  }\n\n  send(msg) {\n    if (!this.connected) return\n    this.delayPing()\n    try {\n      this.connection.send(msg)\n    } catch (e) {\n      this.error(e)\n    }\n  }\n\n  onConnecting() {\n    this.setState('connecting')\n  }\n\n  onConnect() {\n    this.delayPing()\n    this.connected = true\n  }\n\n  onDisconnect() {\n    while (this.timeouts.length > 0) {\n      this.endTimeout()\n    }\n    if (this.pingTimeout) clearTimeout(this.pingTimeout)\n    this.authenticated = false\n    this.connected = false\n    this.setState('disconnected')\n  }\n\n  onMessage(msg) {\n    this.delayPing()\n    let name = msg[0]\n\n    if (!this.authenticated && !BEFORE_AUTH.includes(name)) {\n      this.unauthenticated.push(msg)\n      return\n    }\n\n    this[name + 'Message'](...msg.slice(1))\n  }\n\n  async onAdd(action, meta) {\n    if (!this.authenticated) return\n    if (this.lastAddedCache < meta.added) {\n      this.lastAddedCache = meta.added\n    }\n\n    if (this.received && this.received[meta.id]) {\n      delete this.received[meta.id]\n      return\n    }\n\n    if (this.options.outFilter) {\n      try {\n        let result = await this.options.outFilter(action, meta)\n        if (result) syncMappedEvent(this, action, meta)\n      } catch (e) {\n        this.error(e)\n      }\n    } else {\n      syncMappedEvent(this, action, meta)\n    }\n  }\n\n  syncError(type, options, received) {\n    let err = new LoguxError(type, options, received)\n    this.emitter.emit('error', err)\n    if (!NOT_TO_THROW[type] && this.throwsError) {\n      throw err\n    }\n  }\n\n  error(err) {\n    this.emitter.emit('error', err)\n    this.connection.disconnect('error')\n    if (this.throwsError) {\n      throw err\n    }\n  }\n\n  setState(state) {\n    if (this.state !== state) {\n      this.state = state\n      this.emitter.emit('state')\n    }\n  }\n\n  startTimeout() {\n    if (!this.options.timeout) return\n\n    let ms = this.options.timeout\n    let timeout = setTimeout(() => {\n      if (this.connected) this.connection.disconnect('timeout')\n      this.syncError('timeout', ms)\n    }, ms)\n\n    this.timeouts.push(timeout)\n  }\n\n  endTimeout() {\n    if (this.timeouts.length > 0) {\n      clearTimeout(this.timeouts.shift())\n    }\n  }\n\n  delayPing() {\n    if (!this.options.ping) return\n    if (this.pingTimeout) clearTimeout(this.pingTimeout)\n\n    this.pingTimeout = setTimeout(() => {\n      if (this.connected && this.authenticated) this.sendPing()\n    }, this.options.ping)\n  }\n\n  async syncSinceQuery(lastSynced) {\n    let promises = []\n    await this.log.each({ order: 'added' }, (action, meta) => {\n      if (meta.added <= lastSynced) return false\n      if (this.options.outFilter) {\n        promises.push(\n          this.options\n            .outFilter(action, meta)\n            .then(r => {\n              if (r) {\n                return [action, meta]\n              } else {\n                return false\n              }\n            })\n            .catch(e => {\n              this.error(e)\n            })\n        )\n      } else {\n        promises.push(Promise.resolve([action, meta]))\n      }\n      return true\n    })\n\n    let entries = await Promise.all(promises)\n\n    let data = { added: 0 }\n    data.entries = entries.filter(entry => {\n      if (entry && data.added < entry[1].added) {\n        data.added = entry[1].added\n      }\n      return entry !== false\n    })\n    return data\n  }\n\n  async syncSince(lastSynced) {\n    let data = await this.syncSinceQuery(lastSynced)\n    if (!this.connected) return\n    if (data.entries.length > 0) {\n      if (this.options.outMap) {\n        Promise.all(\n          data.entries.map(i => {\n            return this.options.outMap(i[0], i[1])\n          })\n        )\n          .then(changed => {\n            this.sendSync(data.added, changed)\n          })\n          .catch(e => {\n            this.error(e)\n          })\n      } else {\n        this.sendSync(data.added, data.entries)\n      }\n    } else {\n      this.setState('synchronized')\n    }\n  }\n\n  setLastSent(value) {\n    if (this.lastSent < value) {\n      this.lastSent = value\n      this.log.store.setLastSynced({ sent: value })\n    }\n  }\n\n  setLastReceived(value) {\n    if (this.lastReceived < value) this.lastReceived = value\n    this.log.store.setLastSynced({ received: value })\n  }\n\n  now() {\n    return Date.now()\n  }\n\n  async initialize() {\n    let [synced, added] = await Promise.all([\n      this.log.store.getLastSynced(),\n      this.log.store.getLastAdded()\n    ])\n    this.initialized = true\n    this.lastSent = synced.sent\n    this.lastReceived = synced.received\n    this.lastAddedCache = added\n    if (this.connection.connected) this.onConnect()\n  }\n\n  sendDuilian() {\n    this.send(['duilian', Object.keys(DUILIANS)[0]])\n  }\n\n  duilianMessage(line) {\n    if (DUILIANS[line]) {\n      this.send(['duilian', DUILIANS[line]])\n    }\n  }\n}\n\nBaseNode.prototype.sendConnect = sendConnect\nBaseNode.prototype.sendConnected = sendConnected\nBaseNode.prototype.connectMessage = connectMessage\nBaseNode.prototype.connectedMessage = connectedMessage\n\nBaseNode.prototype.sendSync = sendSync\nBaseNode.prototype.sendSynced = sendSynced\nBaseNode.prototype.syncMessage = syncMessage\nBaseNode.prototype.syncedMessage = syncedMessage\n\nBaseNode.prototype.sendPing = sendPing\nBaseNode.prototype.pingMessage = pingMessage\nBaseNode.prototype.pongMessage = pongMessage\n\nBaseNode.prototype.sendDebug = sendDebug\nBaseNode.prototype.debugMessage = debugMessage\n\nBaseNode.prototype.sendError = sendError\nBaseNode.prototype.errorMessage = errorMessage\n\nBaseNode.prototype.sendHeaders = sendHeaders\nBaseNode.prototype.headersMessage = headersMessage\n\nconst DUILIANS = {\n  : ''\n}\n","export function sendSync(added, entries) {\n  this.startTimeout()\n\n  let data = []\n  for (let [action, originMeta] of entries) {\n    let meta = {}\n    for (let key in originMeta) {\n      if (key === 'id') {\n        meta.id = originMeta.id.split(' ')\n      } else if (key !== 'added') {\n        meta[key] = originMeta[key]\n      }\n    }\n\n    if (this.timeFix) meta.time -= this.timeFix\n    meta.id[0] = parseInt(meta.id[0]) - this.baseTime\n    meta.id[2] = parseInt(meta.id[2])\n    meta.time -= this.baseTime\n\n    if (meta.id[1] === this.localNodeId) {\n      if (meta.id[2] === 0) {\n        meta.id = meta.id[0]\n      } else {\n        meta.id = [meta.id[0], meta.id[2]]\n      }\n    }\n\n    data.unshift(action, meta)\n  }\n\n  this.syncing += 1\n  this.setState('sending')\n  this.send(['sync', added].concat(data))\n}\n\nexport function sendSynced(added) {\n  this.send(['synced', added])\n}\n\nexport async function syncMessage(added, ...data) {\n  let promises = []\n\n  for (let i = 0; i < data.length - 1; i += 2) {\n    let action = data[i]\n    let meta = data[i + 1]\n\n    if (typeof meta.id === 'number') {\n      meta.id = meta.id + this.baseTime + ' ' + this.remoteNodeId + ' ' + 0\n    } else {\n      meta.id[0] = meta.id[0] + this.baseTime\n      if (meta.id.length === 2) {\n        meta.id = meta.id[0] + ' ' + this.remoteNodeId + ' ' + meta.id[1]\n      } else {\n        meta.id = meta.id.join(' ')\n      }\n    }\n\n    meta.time = meta.time + this.baseTime\n    if (this.timeFix) meta.time = meta.time + this.timeFix\n\n    let process = Promise.resolve([action, meta])\n\n    if (this.options.inMap) {\n      process = process\n        .then(([action2, meta2]) => {\n          return this.options.inMap(action2, meta2)\n        })\n        .catch(e => {\n          this.error(e)\n        })\n    }\n\n    process\n      .then(filtered => {\n        if (filtered && this.options.inFilter) {\n          return this.options\n            .inFilter(...filtered)\n            .then(res => {\n              return res ? filtered : false\n            })\n            .catch(e => {\n              this.error(e)\n            })\n        } else {\n          return filtered\n        }\n      })\n      .then(changed => {\n        if (!changed) return false\n        if (this.received) this.received[changed[1].id] = true\n        return this.log.add(changed[0], changed[1])\n      })\n\n    promises.push(process)\n  }\n\n  await Promise.all(promises)\n  this.setLastReceived(added)\n  this.sendSynced(added)\n}\n\nexport function syncedMessage(synced) {\n  this.endTimeout()\n  this.setLastSent(synced)\n  if (this.syncing > 0) this.syncing -= 1\n  if (this.syncing === 0) {\n    this.setState('synchronized')\n  }\n}\n","export function sendPing() {\n  this.startTimeout()\n  this.send(['ping', this.lastAddedCache])\n  if (this.pingTimeout) clearTimeout(this.pingTimeout)\n}\n\nexport function pingMessage(synced) {\n  this.setLastReceived(synced)\n  if (this.connected && this.authenticated) {\n    this.send(['pong', this.lastAddedCache])\n  }\n}\n\nexport function pongMessage(synced) {\n  this.setLastReceived(synced)\n  this.endTimeout()\n}\n","export function sendDebug(type, data) {\n  this.send(['debug', type, data])\n}\n\nexport function debugMessage(type, data) {\n  this.emitter.emit('debug', type, data)\n}\n","export function sendError(error) {\n  let message = ['error', error.type]\n  if (typeof error.options !== 'undefined') message.push(error.options)\n  this.send(message)\n\n  this.emitter.emit('clientError', error)\n}\n\nexport function errorMessage(type, options) {\n  this.syncError(type, options, true)\n}\n","export function sendHeaders(data) {\n  this.send(['headers', data])\n}\n\nexport function headersMessage(data) {\n  this.remoteHeaders = data\n  this.emitter.emit('headers', data)\n}\n","import { BaseNode } from '../base-node/index.js'\n\nconst DEFAULT_OPTIONS = {\n  fixTime: true,\n  timeout: 20000,\n  ping: 5000\n}\n\nexport class ClientNode extends BaseNode {\n  constructor(nodeId, log, connection, options = {}) {\n    options = { ...DEFAULT_OPTIONS, ...options }\n    super(nodeId, log, connection, options)\n  }\n\n  onConnect() {\n    if (!this.connected) {\n      this.connected = true\n      this.initializing = this.initializing.then(() => {\n        if (this.connected) this.sendConnect()\n      })\n    }\n  }\n}\n","import { createNanoEvents } from 'nanoevents'\n\nclass LocalConnection {\n  constructor(pair, type) {\n    this.connected = false\n    this.emitter = createNanoEvents()\n    this.type = type\n    this.pair = pair\n  }\n\n  other() {\n    if (this.type === 'left') {\n      return this.pair.right\n    } else {\n      return this.pair.left\n    }\n  }\n\n  on(event, listener) {\n    return this.emitter.on(event, listener)\n  }\n\n  connect() {\n    if (this.connected) {\n      throw new Error('Connection already established')\n    } else {\n      this.emitter.emit('connecting')\n      return new Promise(resolve => {\n        setTimeout(() => {\n          this.other().connected = true\n          this.connected = true\n          this.other().emitter.emit('connect')\n          this.emitter.emit('connect')\n          resolve()\n        }, this.pair.delay)\n      })\n    }\n  }\n\n  disconnect(reason) {\n    if (!this.connected) {\n      throw new Error('Connection already finished')\n    } else {\n      this.connected = false\n      this.emitter.emit('disconnect', reason)\n      return new Promise(resolve => {\n        setTimeout(() => {\n          this.other().connected = false\n          this.other().emitter.emit('disconnect')\n          resolve()\n        }, 1)\n      })\n    }\n  }\n\n  send(message) {\n    if (this.connected) {\n      setTimeout(() => {\n        this.other().emitter.emit('message', message)\n      }, this.pair.delay)\n    } else {\n      throw new Error('Connection should be started before sending a message')\n    }\n  }\n}\n\nexport class LocalPair {\n  constructor(delay = 1) {\n    this.delay = delay\n    this.left = new LocalConnection(this, 'left')\n    this.right = new LocalConnection(this, 'right')\n  }\n}\n","const DEFAULT_OPTIONS = {\n  minDelay: 1000,\n  maxDelay: 5000,\n  attempts: Infinity\n}\n\nconst FATAL_ERRORS = [\n  'wrong-protocol',\n  'wrong-subprotocol',\n  'wrong-credentials'\n]\n\nexport class Reconnect {\n  constructor(connection, options = {}) {\n    this.connection = connection\n    this.options = { ...DEFAULT_OPTIONS, ...options }\n\n    this.reconnecting = connection.connected\n    this.connecting = false\n    this.attempts = 0\n\n    this.unbind = [\n      this.connection.on('message', msg => {\n        if (msg[0] === 'error' && FATAL_ERRORS.includes(msg[1])) {\n          this.reconnecting = false\n        }\n      }),\n      this.connection.on('connecting', () => {\n        this.connecting = true\n      }),\n      this.connection.on('connect', () => {\n        this.attempts = 0\n        this.connecting = false\n      }),\n      this.connection.on('disconnect', () => {\n        this.connecting = false\n        if (this.reconnecting) this.reconnect()\n      }),\n      () => {\n        clearTimeout(this.timer)\n      }\n    ]\n\n    let visibility = () => {\n      if (this.reconnecting && !this.connected && !this.connecting) {\n        if (typeof document !== 'undefined' && !document.hidden) this.connect()\n      }\n    }\n    let connect = () => {\n      if (this.reconnecting && !this.connected && !this.connecting) {\n        if (navigator.onLine) this.connect()\n      }\n    }\n    let disconnect = () => {\n      this.disconnect('freeze')\n    }\n    if (\n      typeof document !== 'undefined' &&\n      typeof window !== 'undefined' &&\n      document.addEventListener &&\n      window.addEventListener\n    ) {\n      document.addEventListener('visibilitychange', visibility, false)\n      window.addEventListener('focus', connect, false)\n      window.addEventListener('online', connect, false)\n      window.addEventListener('resume', connect, false)\n      window.addEventListener('freeze', disconnect, false)\n      this.unbind.push(() => {\n        document.removeEventListener('visibilitychange', visibility, false)\n        window.removeEventListener('focus', connect, false)\n        window.removeEventListener('online', connect, false)\n        window.removeEventListener('resume', connect, false)\n        window.removeEventListener('freeze', disconnect, false)\n      })\n    }\n  }\n\n  connect() {\n    this.attempts += 1\n    this.reconnecting = true\n    return this.connection.connect()\n  }\n\n  disconnect(reason) {\n    if (reason !== 'timeout' && reason !== 'error' && reason !== 'freeze') {\n      this.reconnecting = false\n    }\n    return this.connection.disconnect(reason)\n  }\n\n  destroy() {\n    for (let i of this.unbind) i()\n    this.disconnect('destroy')\n  }\n\n  reconnect() {\n    if (this.attempts > this.options.attempts - 1) {\n      this.reconnecting = false\n      this.attempts = 0\n      return\n    }\n\n    let delay = this.nextDelay()\n    this.timer = setTimeout(() => {\n      if (this.reconnecting && !this.connecting && !this.connected) {\n        this.connect()\n      }\n    }, delay)\n  }\n\n  send(...args) {\n    return this.connection.send(...args)\n  }\n\n  on(...args) {\n    return this.connection.on(...args)\n  }\n\n  nextDelay() {\n    let base = this.options.minDelay * 2 ** this.attempts\n    let rand = Math.random()\n    let deviation = rand * 0.5 * base\n    if (Math.floor(rand * 10) === 1) deviation = -deviation\n    return Math.min(base + deviation, this.options.maxDelay) || 0\n  }\n\n  get connected() {\n    return this.connection.connected\n  }\n\n  get emitter() {\n    return this.connection.emitter\n  }\n}\n","export function parseId(nodeId) {\n  if (nodeId.includes(' ')) nodeId = nodeId.split(' ')[1]\n  let parts = nodeId.split(':')\n  if (parts.length === 1) {\n    return { nodeId, userId: undefined, clientId: nodeId }\n  } else {\n    let userId = parts[0]\n    return { nodeId, userId, clientId: parts[0] + ':' + parts[1] }\n  }\n}\n","export function status(client, callback, options = {}) {\n  let observable = client.on ? client : client.node\n  let disconnected = observable.state === 'disconnected'\n  let wait = false\n  let old = false\n\n  if (typeof options.duration === 'undefined') options.duration = 3000\n\n  let timeout\n  let unbind = []\n  let processing = {}\n\n  function setSynchronized() {\n    if (Object.keys(processing).length === 0) {\n      if (wait) {\n        wait = false\n        callback('synchronizedAfterWait')\n        timeout = setTimeout(() => {\n          callback('synchronized')\n        }, options.duration)\n      } else {\n        callback('synchronized')\n      }\n    }\n  }\n\n  function changeState() {\n    clearTimeout(timeout)\n\n    if (old) return\n    if (observable.state === 'disconnected') {\n      disconnected = true\n      callback(wait ? 'wait' : 'disconnected')\n    } else if (observable.state === 'synchronized') {\n      disconnected = false\n      setSynchronized()\n    } else if (observable.state === 'connecting') {\n      timeout = setTimeout(() => {\n        callback('connecting' + (wait ? 'AfterWait' : ''))\n      }, 100)\n    } else {\n      callback(client.state + (wait ? 'AfterWait' : ''))\n    }\n  }\n\n  unbind.push(observable.on('state', changeState))\n\n  unbind.push(\n    client.node.on('error', error => {\n      if (\n        error.type === 'wrong-protocol' ||\n        error.type === 'wrong-subprotocol'\n      ) {\n        old = true\n        callback('protocolError')\n      } else if (error.type !== 'timeout') {\n        callback('syncError', { error })\n      }\n    })\n  )\n\n  unbind.push(\n    client.node.on('clientError', error => {\n      callback('syncError', { error })\n    })\n  )\n\n  let log = client.on ? client : client.log\n  unbind.push(\n    log.on('add', (action, meta) => {\n      if (action.type === 'logux/subscribe') {\n        return\n      } else if (action.type === 'logux/unsubscribe') {\n        return\n      }\n\n      if (action.type === 'logux/processed') {\n        delete processing[action.id]\n        setSynchronized()\n      } else if (action.type === 'logux/undo') {\n        delete processing[action.id]\n      } else if (meta.sync) {\n        processing[meta.id] = true\n      }\n\n      if (action.type === 'logux/undo' && action.reason) {\n        if (action.reason === 'denied') {\n          callback('denied', { action, meta })\n        } else {\n          callback('error', { action, meta })\n        }\n      } else if (disconnected && meta.sync && meta.added) {\n        if (!wait) callback('wait')\n        wait = true\n      }\n    })\n  )\n\n  changeState()\n\n  return () => {\n    for (let i of unbind) i()\n  }\n}\n","import { status } from '../status/index.js'\n\nfunction injectStyles(element, styles) {\n  for (let i in styles) {\n    element.style[i] = styles[i]\n  }\n}\n\nfunction setPosition(element, position) {\n  let style = element.style\n  if (position === 'middle-center' || position === 'center-middle') {\n    style.top = '50%'\n    style.left = '50%'\n    style.transform = 'translate(-50%, -50%)'\n  } else {\n    position.split('-').forEach(pos => {\n      if (pos === 'middle') {\n        style.top = '50%'\n        style.transform = 'translateY(-50%)'\n      } else if (pos === 'center') {\n        style.left = '50%'\n        style.transform = 'translateX(-50%)'\n      } else {\n        style[pos] = '0'\n      }\n    })\n  }\n}\n\nconst RESET = {\n  boxSizing: 'content-box',\n  visibility: 'visible',\n  textIndent: '0',\n  textTransform: 'none',\n  wordSpacing: 'normal',\n  letterSpacing: 'normal',\n  fontStyle: 'normal',\n  fontVariant: 'normal',\n  fontWeight: 'normal',\n  lineHeight: 'auto'\n}\n\nexport function badge(client, opts) {\n  let messages = opts.messages\n  let position = opts.position || 'bottom-right'\n  let styles = opts.styles\n\n  let widget = document.createElement('div')\n  let text = document.createElement('span')\n\n  widget.setAttribute('role', 'alert')\n\n  injectStyles(widget, RESET)\n  injectStyles(widget, styles.base)\n  injectStyles(text, styles.text)\n  setPosition(widget, position)\n\n  let show = (style, msg) => {\n    text.innerHTML = msg\n    injectStyles(widget, style)\n    widget.style.display = 'block'\n  }\n\n  let hide = () => {\n    widget.style.display = 'none'\n  }\n\n  let unbind = status(\n    client,\n    state => {\n      if (state === 'sendingAfterWait' || state === 'connectingAfterWait') {\n        show(styles.sending, messages.sending)\n      } else if (state === 'synchronizedAfterWait') {\n        show(styles.synchronized, messages.synchronized)\n      } else if (state === 'synchronized') {\n        hide(widget)\n      } else if (state === 'disconnected') {\n        show(styles.disconnected, messages.disconnected)\n      } else if (state === 'wait') {\n        show(styles.wait, messages.wait)\n      } else if (state === 'protocolError') {\n        show(styles.protocolError, messages.protocolError)\n      } else if (state === 'syncError') {\n        show(styles.error, messages.syncError)\n      } else if (state === 'error') {\n        show(styles.error, messages.error)\n      } else if (state === 'denied') {\n        show(styles.error, messages.denied)\n      }\n    },\n    opts\n  )\n\n  widget.appendChild(text)\n  document.body.appendChild(widget)\n\n  return () => {\n    unbind()\n    document.body.removeChild(widget)\n  }\n}\n\nexport let badgeRu = {\n  synchronized: '  ',\n  disconnected: ' ',\n  wait: ' <br>   ',\n  sending: '  ',\n  syncError: '  <br>   ',\n  error: '  <br>  ',\n  denied: ' <br>  ',\n  protocolError: '  <br> '\n}\n\nexport let badgeEn = {\n  synchronized: 'Your data has been saved',\n  disconnected: 'No Internet connection',\n  wait: 'No Internet connection<br>Your data has not been saved',\n  sending: 'Data saving',\n  syncError: 'Server error<br>Your data has not been saved',\n  error: 'Server error<br>You changes was reverted',\n  denied: 'You have no access<br>You changes was reverted',\n  protocolError: 'Saving is not working<br>Refresh the page'\n}\n","import { urlAlphabet } from './url-alphabet/index.js'\nif (process.env.NODE_ENV !== 'production') {\n  if (\n    typeof navigator !== 'undefined' &&\n    navigator.product === 'ReactNative' &&\n    typeof crypto === 'undefined'\n  ) {\n    throw new Error(\n      'React Native does not have a built-in secure random generator. ' +\n        'If you dont need unpredictable IDs use `nanoid/non-secure`. ' +\n        'For secure IDs, import `react-native-get-random-values` ' +\n        'before Nano ID.'\n    )\n  }\n  if (typeof msCrypto !== 'undefined' && typeof crypto === 'undefined') {\n    throw new Error(\n      'Import file with `if (!window.crypto) window.crypto = window.msCrypto`' +\n        ' before importing Nano ID to fix IE 11 support'\n    )\n  }\n  if (typeof crypto === 'undefined') {\n    throw new Error(\n      'Your browser does not have secure random generator. ' +\n        'If you dont need unpredictable IDs, you can use nanoid/non-secure.'\n    )\n  }\n}\nlet random = bytes => crypto.getRandomValues(new Uint8Array(bytes))\nlet customRandom = (alphabet, size, getRandom) => {\n  let mask = (2 << (Math.log(alphabet.length - 1) / Math.LN2)) - 1\n  let step = -~((1.6 * mask * size) / alphabet.length)\n  return () => {\n    let id = ''\n    while (true) {\n      let bytes = getRandom(step)\n      let j = step\n      while (j--) {\n        id += alphabet[bytes[j] & mask] || ''\n        if (id.length === size) return id\n      }\n    }\n  }\n}\nlet customAlphabet = (alphabet, size) => customRandom(alphabet, size, random)\nlet nanoid = (size = 21) => {\n  let id = ''\n  let bytes = crypto.getRandomValues(new Uint8Array(size))\n  while (size--) {\n    let byte = bytes[size] & 63\n    if (byte < 36) {\n      id += byte.toString(36)\n    } else if (byte < 62) {\n      id += (byte - 26).toString(36).toUpperCase()\n    } else if (byte < 63) {\n      id += '_'\n    } else {\n      id += '-'\n    }\n  }\n  return id\n}\nexport { nanoid, customAlphabet, customRandom, urlAlphabet, random }\n","export class LoguxUndoError extends Error {\n  constructor(action) {\n    let type = action.action ? action.action.type : 'action'\n    super(`Server undid ${type} because of ${action.reason}`)\n    this.name = 'LoguxUndoError'\n    this.action = action\n  }\n}\n","import { createNanoEvents } from 'nanoevents'\nimport {\n  isFirstOlder,\n  WsConnection,\n  MemoryStore,\n  ClientNode,\n  Reconnect,\n  parseId,\n  Log\n} from '@logux/core'\nimport { nanoid } from 'nanoid'\n\nimport { LoguxUndoError } from '../logux-undo-error/index.js'\nimport { track } from '../track/index.js'\n\nlet ALLOWED_META = ['id', 'time', 'subprotocol']\n\nfunction tabPing(c) {\n  localStorage.setItem(c.options.prefix + ':tab:' + c.tabId, Date.now())\n}\n\nfunction cleanTabActions(client, id) {\n  client.log.removeReason('tab' + id).then(() => {\n    if (client.isLocalStorage) {\n      localStorage.removeItem(client.options.prefix + ':tab:' + id)\n    }\n  })\n}\n\nexport class Client {\n  constructor(opts = {}) {\n    this.options = opts\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof this.options.server === 'undefined') {\n        throw new Error('Missed server option in Logux client')\n      }\n      if (typeof this.options.subprotocol === 'undefined') {\n        throw new Error('Missed subprotocol option in Logux client')\n      }\n      if (typeof this.options.userId === 'undefined') {\n        throw new Error(\n          'Missed userId option in Logux client. ' +\n            'Pass false if you have no users.'\n        )\n      }\n      if (this.options.userId === false) {\n        throw new Error('Replace userId: false to userId: \"false\"')\n      }\n      if (typeof this.options.userId !== 'string') {\n        throw new Error('userId must be a string')\n      }\n      if (this.options.userId.includes(':')) {\n        throw new Error('userId cant contain colon character')\n      }\n    }\n\n    if (typeof this.options.prefix === 'undefined') {\n      this.options.prefix = 'logux'\n    }\n\n    this.isLocalStorage = false\n    if (typeof localStorage !== 'undefined') {\n      let random = nanoid()\n      try {\n        localStorage.setItem(random, '1')\n        localStorage.removeItem(random)\n        this.isLocalStorage = true\n      } catch {}\n    }\n\n    if (!this.options.time) {\n      this.clientId = this.options.userId + ':' + this.getClientId()\n      this.tabId = nanoid(8)\n    } else {\n      this.tabId = this.options.time.lastId + 1 + ''\n      this.clientId = this.options.userId + ':' + this.tabId\n    }\n\n    this.nodeId = this.clientId + ':' + this.tabId\n    let store = this.options.store || new MemoryStore()\n\n    let log\n    if (this.options.time) {\n      log = this.options.time.nextLog({ store, nodeId: this.nodeId })\n    } else {\n      log = new Log({ store, nodeId: this.nodeId })\n    }\n    this.log = log\n\n    log.on('preadd', (action, meta) => {\n      if (parseId(meta.id).nodeId === this.nodeId && !meta.subprotocol) {\n        meta.subprotocol = this.options.subprotocol\n      }\n      if (meta.sync && !meta.resubscribe) meta.reasons.push('syncing')\n    })\n\n    this.last = {}\n    this.subscriptions = {}\n    let subscribing = {}\n    let unsubscribing = {}\n\n    this.emitter = createNanoEvents()\n    this.on('add', (action, meta) => {\n      let type = action.type\n      let json, last\n      if (type === 'logux/processed' || type === 'logux/undo') {\n        this.log.removeReason('syncing', { id: action.id })\n      }\n      if (type === 'logux/subscribe' && !meta.resubscribe) {\n        subscribing[meta.id] = action\n      } else if (type === 'logux/unsubscribe') {\n        unsubscribing[meta.id] = action\n      } else if (type === 'logux/processed') {\n        if (unsubscribing[action.id]) {\n          let unsubscription = unsubscribing[action.id]\n          json = JSON.stringify({ ...unsubscription, type: 'logux/subscribe' })\n          let subscribers = this.subscriptions[json]\n          if (subscribers) {\n            if (subscribers === 1) {\n              delete this.subscriptions[json]\n            } else {\n              this.subscriptions[json] = subscribers - 1\n            }\n          }\n        }\n        if (subscribing[action.id]) {\n          let subscription = subscribing[action.id]\n          delete subscribing[action.id]\n          json = JSON.stringify(subscription)\n          if (this.subscriptions[json]) {\n            this.subscriptions[json] += 1\n          } else {\n            this.subscriptions[json] = 1\n          }\n          last = this.last[subscription.channel]\n          if (!last || isFirstOlder(last, meta)) {\n            this.last[subscription.channel] = { id: meta.id, time: meta.time }\n          }\n        }\n        if (type === 'logux/processed' && this.processing[action.id]) {\n          this.processing[action.id][1](meta)\n          delete this.processing[action.id]\n        }\n      } else if (type === 'logux/undo') {\n        if (this.processing[action.id]) {\n          this.processing[action.id][2](new LoguxUndoError(action))\n          delete this.processing[action.id]\n        }\n        delete subscribing[action.id]\n        delete unsubscribing[action.id]\n      } else if (meta.channels) {\n        if (!meta.id.includes(' ' + this.clientId + ':')) {\n          meta.channels.forEach(channel => {\n            last = this.last[channel]\n            if (!last || isFirstOlder(last, meta)) {\n              this.last[channel] = { id: meta.id, time: meta.time }\n            }\n          })\n        }\n      }\n      if (process.env.NODE_ENV !== 'production') {\n        if (type === 'logux/subscribe' || type === 'logux/unsubscribe') {\n          if (!meta.sync) {\n            console.error(type + ' action without meta.sync')\n          }\n        }\n      }\n    })\n\n    this.tabPing = 60000\n    this.tabTimeout = 10 * this.tabPing\n    let reason = 'tab' + this.tabId\n    if (this.isLocalStorage) {\n      let unbind = log.on('add', (action, meta) => {\n        if (meta.reasons.includes(reason)) {\n          tabPing(this)\n          this.pinging = setInterval(() => {\n            tabPing(this)\n          }, this.tabPing)\n          unbind()\n        }\n      })\n    }\n\n    let connection\n    if (typeof this.options.server === 'string') {\n      let ws = new WsConnection(this.options.server)\n      connection = new Reconnect(ws, {\n        minDelay: this.options.minDelay,\n        maxDelay: this.options.maxDelay,\n        attempts: this.options.attempts\n      })\n    } else {\n      connection = this.options.server\n    }\n\n    let outFilter = async (action, meta) => {\n      return !!meta.sync && parseId(meta.id).userId === this.options.userId\n    }\n\n    let outMap = async (action, meta) => {\n      let filtered = {}\n      for (let i in meta) {\n        if (i === 'subprotocol') {\n          if (meta.subprotocol !== this.options.subprotocol) {\n            filtered.subprotocol = meta.subprotocol\n          }\n        } else if (ALLOWED_META.includes(i)) {\n          filtered[i] = meta[i]\n        }\n      }\n      return [action, filtered]\n    }\n\n    if (!this.options.time) {\n      if (typeof this.options.timeout === 'undefined') {\n        this.options.timeout = 20000\n      }\n      if (typeof this.options.ping === 'undefined') {\n        this.options.ping = 5000\n      }\n    }\n\n    this.node = new ClientNode(this.nodeId, this.log, connection, {\n      subprotocol: this.options.subprotocol,\n      outFilter,\n      timeout: this.options.timeout,\n      fixTime: !this.options.time,\n      outMap,\n      token: this.options.token,\n      ping: this.options.ping\n    })\n\n    if (/^ws:\\/\\//.test(this.options.server) && !opts.allowDangerousProtocol) {\n      let unbindEnvTest = this.node.on('state', () => {\n        if (this.node.state === 'synchronized') {\n          unbindEnvTest()\n          if (this.node.remoteHeaders.env !== 'development') {\n            console.error(\n              'Without SSL, old proxies block WebSockets. ' +\n                'Use WSS for Logux or set allowDangerousProtocol option.'\n            )\n            this.destroy()\n          }\n        }\n      })\n    }\n\n    this.node.on('debug', (type, stack) => {\n      if (type === 'error') {\n        console.error('Error on Logux server:\\n', stack)\n      }\n    })\n\n    let disconnected = true\n    this.node.on('state', () => {\n      let state = this.node.state\n      if (state === 'synchronized' || state === 'sending') {\n        if (disconnected) {\n          disconnected = false\n          for (let i in this.subscriptions) {\n            let action = JSON.parse(i)\n            let since = this.last[action.channel]\n            if (since) action.since = since\n            this.log.add(action, { sync: true, resubscribe: true })\n          }\n        }\n      } else if (this.node.state === 'disconnected') {\n        disconnected = true\n      }\n    })\n\n    this.onUnload = this.onUnload.bind(this)\n    if (typeof window !== 'undefined' && window.addEventListener) {\n      window.addEventListener('unload', this.onUnload)\n    }\n\n    this.processing = {}\n  }\n\n  get state() {\n    return this.node.state\n  }\n\n  get connected() {\n    return this.state !== 'disconnected' && this.state !== 'connecting'\n  }\n\n  start() {\n    this.cleanPrevActions()\n    this.node.connection.connect()\n  }\n\n  sync(action, meta = {}) {\n    meta.sync = true\n    if (typeof meta.id === 'undefined') {\n      meta.id = this.log.generateId()\n    }\n\n    this.log.add(action, meta)\n    return track(this, meta.id)\n  }\n\n  type(type, listener, opts) {\n    return this.log.type(type, listener, opts)\n  }\n\n  on(event, listener) {\n    if (event === 'state') {\n      return this.node.emitter.on(event, listener)\n    } else if (event === 'user') {\n      return this.emitter.on(event, listener)\n    } else {\n      return this.log.emitter.on(event, listener)\n    }\n  }\n\n  changeUser(userId, token) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof userId !== 'string') {\n        throw new Error('userId must be a string')\n      }\n      if (userId.includes(':')) {\n        throw new Error('userId cant contain colon character')\n      }\n    }\n\n    let wasConnected = this.node.connected\n    if (wasConnected) this.node.connection.disconnect('destroy')\n\n    this.options.userId = userId\n    this.options.token = token\n    this.clientId = userId + ':' + this.getClientId()\n    this.nodeId = this.clientId + ':' + this.tabId\n\n    this.log.nodeId = this.nodeId\n    this.node.localNodeId = this.nodeId\n    this.node.options.token = token\n\n    this.emitter.emit('user', userId)\n    if (wasConnected) this.node.connection.connect()\n  }\n\n  waitFor(state) {\n    if (this.state === state) {\n      return Promise.resolve()\n    }\n    return new Promise(resolve => {\n      let unbind = this.on('state', () => {\n        if (this.state === state) {\n          unbind()\n          resolve()\n        }\n      })\n    })\n  }\n\n  destroy() {\n    this.onUnload()\n    this.node.destroy()\n    clearInterval(this.pinging)\n    if (typeof window !== 'undefined' && window.removeEventListener) {\n      window.removeEventListener('unload', this.onUnload)\n    }\n  }\n\n  clean() {\n    this.destroy()\n    return this.log.store.clean ? this.log.store.clean() : Promise.resolve()\n  }\n\n  cleanPrevActions() {\n    if (!this.isLocalStorage) return\n\n    for (let i in localStorage) {\n      let prefix = this.options.prefix + ':tab:'\n      if (i.slice(0, prefix.length) === prefix) {\n        let time = parseInt(localStorage.getItem(i))\n        if (Date.now() - time > this.tabTimeout) {\n          cleanTabActions(this, i.slice(prefix.length))\n        }\n      }\n    }\n  }\n\n  onUnload() {\n    if (this.pinging) cleanTabActions(this, this.tabId)\n  }\n\n  getClientId() {\n    return nanoid(8)\n  }\n}\n","import { LoguxError, actionEvents } from '@logux/core'\n\nimport { Client } from '../client/index.js'\n\nfunction storageKey(client, name) {\n  return client.options.prefix + ':' + client.options.userId + ':' + name\n}\n\nfunction sendToTabs(client, event, data) {\n  if (!client.isLocalStorage) return\n  let key = storageKey(client, event)\n  let json = JSON.stringify(data)\n  try {\n    localStorage.setItem(key, json)\n  } catch (e) {\n    console.error(e)\n    client.isLocalStorage = false\n    client.role = 'leader'\n    client.emitter.emit('role')\n    client.node.connection.connect()\n  }\n}\n\nfunction getLeader(client) {\n  let data = localStorage.getItem(storageKey(client, 'leader'))\n  let json = []\n  if (typeof data === 'string') json = JSON.parse(data)\n  return json\n}\n\nfunction leaderPing(client) {\n  sendToTabs(client, 'leader', [client.tabId, Date.now()])\n}\n\nfunction onDeadLeader(client) {\n  if (client.state !== 'disconnected') {\n    setState(client, 'disconnected')\n  }\n  startElection(client)\n}\n\nfunction watchForLeader(client) {\n  clearTimeout(client.watching)\n  client.watching = setTimeout(() => {\n    if (!isActiveLeader(client)) {\n      onDeadLeader(client)\n    } else {\n      watchForLeader(client)\n    }\n  }, client.roleTimeout)\n}\n\nfunction compareSubprotocols(left, right) {\n  let leftParts = left.split('.')\n  let rightParts = right.split('.')\n  for (let i = 0; i < 3; i++) {\n    let leftNumber = parseInt(leftParts[i] || 0)\n    let rightNumber = parseInt(rightParts[i] || 0)\n    if (leftNumber > rightNumber) {\n      return 1\n    } else if (leftNumber < rightNumber) {\n      return -1\n    }\n  }\n  return 0\n}\n\nfunction setRole(client, role) {\n  if (client.role !== role) {\n    let node = client.node\n    client.role = role\n\n    clearTimeout(client.watching)\n    if (role === 'leader') {\n      localStorage.removeItem(storageKey(client, 'state'))\n      client.leadership = setInterval(() => {\n        if (!client.unloading) leaderPing(client)\n      }, client.leaderPing)\n      node.connection.connect()\n    } else {\n      clearTimeout(client.elections)\n      clearInterval(client.leadership)\n\n      if (node.state !== 'disconnected') {\n        client.node.connection.disconnect()\n      }\n    }\n\n    if (role === 'follower') {\n      let state = 'disconnected'\n      let json = localStorage.getItem(storageKey(client, 'state'))\n      if (json && json !== null) state = JSON.parse(json)\n      if (state !== client.state) {\n        client.state = state\n        client.emitter.emit('state')\n      }\n    }\n\n    client.emitter.emit('role')\n  }\n}\n\nfunction isActiveLeader(client) {\n  let leader = getLeader(client)\n  return leader[1] && leader[1] >= Date.now() - client.leaderTimeout\n}\n\nfunction startElection(client) {\n  leaderPing(client)\n  setRole(client, 'candidate')\n  client.elections = setTimeout(() => {\n    let data = getLeader(client, 'leader')\n    if (data[0] === client.tabId) {\n      setRole(client, 'leader')\n    } else {\n      setRole(client, 'follower')\n      watchForLeader(client)\n    }\n  }, client.electionDelay)\n}\n\nfunction setState(client, state) {\n  client.state = state\n  client.emitter.emit('state')\n  sendToTabs(client, 'state', client.state)\n}\n\nfunction isMemory(store) {\n  return Array.isArray(store.entries) && Array.isArray(store.added)\n}\n\nexport class CrossTabClient extends Client {\n  constructor(opts = {}) {\n    super(opts)\n\n    this.role = 'candidate'\n\n    this.roleTimeout = 3000 + Math.floor(Math.random() * 1000)\n    this.leaderTimeout = 5000\n    this.leaderPing = 2000\n    this.electionDelay = 1000\n\n    this.leaderState = this.node.state\n\n    this.node.on('state', () => {\n      if (this.role === 'leader') {\n        setState(this, this.node.state)\n      }\n    })\n\n    this.log.on('add', (action, meta) => {\n      actionEvents(this.emitter, 'add', action, meta)\n      if (meta.tab !== this.tabId) {\n        sendToTabs(this, 'add', [this.tabId, action, meta])\n      }\n    })\n    this.log.on('clean', (action, meta) => {\n      actionEvents(this.emitter, 'clean', action, meta)\n    })\n\n    if (typeof window !== 'undefined' && window.addEventListener) {\n      window.addEventListener('storage', e => this.onStorage(e))\n      window.addEventListener('unload', e => this.onUnload(e))\n    }\n\n    if (this.isLocalStorage) {\n      let subprotocolKey = storageKey(this, 'subprotocol')\n      if (localStorage.getItem(subprotocolKey) !== this.options.subprotocol) {\n        sendToTabs(this, 'subprotocol', this.options.subprotocol)\n      }\n    }\n  }\n\n  get state() {\n    return this.leaderState\n  }\n\n  set state(value) {\n    this.leaderState = value\n  }\n\n  start() {\n    this.cleanPrevActions()\n\n    if (!this.isLocalStorage) {\n      this.role = 'leader'\n      this.emitter.emit('role')\n      this.node.connection.connect()\n      return\n    }\n\n    if (isActiveLeader(this)) {\n      setRole(this, 'follower')\n      watchForLeader(this)\n    } else {\n      startElection(this)\n    }\n  }\n\n  destroy() {\n    super.destroy()\n\n    clearTimeout(this.watching)\n    clearTimeout(this.elections)\n    clearInterval(this.leadership)\n    if (typeof window !== 'undefined' && window.removeEventListener) {\n      window.removeEventListener('storage', this.onStorage)\n    }\n  }\n\n  clean() {\n    if (this.isLocalStorage) {\n      localStorage.removeItem(storageKey(this, 'add'))\n      localStorage.removeItem(storageKey(this, 'state'))\n      localStorage.removeItem(storageKey(this, 'client'))\n      localStorage.removeItem(storageKey(this, 'leader'))\n    }\n    return super.clean()\n  }\n\n  changeUser(userId, token) {\n    sendToTabs(this, 'user', [this.tabId, userId])\n    super.changeUser(userId, token)\n  }\n\n  type(type, listener, opts = {}) {\n    if (opts.event === 'preadd') {\n      return this.log.type(type, listener, opts)\n    } else {\n      let event = opts.event || 'add'\n      let id = opts.id || ''\n      return this.emitter.on(`${event}-${type}-${id}`, listener)\n    }\n  }\n\n  on(event, listener) {\n    if (event === 'preadd') {\n      return this.log.emitter.on(event, listener)\n    } else {\n      return this.emitter.on(event, listener)\n    }\n  }\n\n  onStorage(e) {\n    if (e.newValue === null) return\n\n    let data\n    if (e.key === storageKey(this, 'add')) {\n      data = JSON.parse(e.newValue)\n      if (data[0] !== this.tabId) {\n        let action = data[1]\n        let meta = data[2]\n        if (!meta.tab || meta.tab === this.tabId) {\n          if (isMemory(this.log.store)) {\n            this.log.store.add(action, meta)\n          }\n          actionEvents(this.emitter, 'add', action, meta)\n          if (this.role === 'leader') {\n            this.node.onAdd(action, meta)\n          }\n        }\n      }\n    } else if (e.key === storageKey(this, 'leader')) {\n      data = JSON.parse(e.newValue)\n      if (data.length === 0) {\n        onDeadLeader(this)\n      } else if (data[0] !== this.tabId && this.role !== 'candidate') {\n        setRole(this, 'follower')\n        watchForLeader(this)\n      }\n    } else if (e.key === storageKey(this, 'state')) {\n      let state = JSON.parse(localStorage.getItem(e.key))\n      if (this.leaderState !== state) {\n        this.leaderState = state\n        this.emitter.emit('state')\n      }\n    } else if (e.key === storageKey(this, 'user')) {\n      data = JSON.parse(e.newValue)\n      if (data[0] !== this.tabId) {\n        this.emitter.emit('user', data[1])\n      }\n    } else if (e.key === storageKey(this, 'subprotocol')) {\n      let other = JSON.parse(e.newValue)\n      let compare = compareSubprotocols(this.options.subprotocol, other)\n      if (compare === 1) {\n        sendToTabs(this, 'subprotocol', this.options.subprotocol)\n      } else if (compare === -1) {\n        let err = new LoguxError(\n          'wrong-subprotocol',\n          { supported: other, used: this.options.subprotocol },\n          true\n        )\n        this.node.emitter.emit('error', err)\n      }\n    }\n  }\n\n  onUnload() {\n    if (this.role === 'leader') {\n      this.unloading = true\n      sendToTabs(this, 'leader', [])\n    }\n    super.onUnload()\n  }\n\n  getClientId() {\n    let key = storageKey(this, 'client')\n    if (!this.isLocalStorage) {\n      return super.getClientId()\n    } else if (localStorage.getItem(key)) {\n      return localStorage.getItem(key)\n    } else {\n      let clientId = super.getClientId()\n      localStorage.setItem(key, clientId)\n      return clientId\n    }\n  }\n}\n","function block(e) {\n  e.returnValue = 'unsynced'\n  return 'unsynced'\n}\n\nexport function confirm(client) {\n  let disconnected = client.state === 'disconnected'\n  let wait = false\n\n  let update = () => {\n    if (client.state === 'disconnected') {\n      disconnected = true\n    } else if (client.state === 'synchronized') {\n      disconnected = false\n      wait = false\n    }\n\n    if (typeof window !== 'undefined' && window.addEventListener) {\n      if (client.role !== 'follower' && wait && disconnected) {\n        window.addEventListener('beforeunload', block)\n      } else {\n        window.removeEventListener('beforeunload', block)\n      }\n    }\n  }\n\n  let unbind = []\n  unbind.push(client.on('role', update))\n  unbind.push(client.on('state', update))\n  update()\n\n  unbind.push(\n    client.on('add', (action, meta) => {\n      if (action.type === 'logux/subscribe') {\n        return\n      } else if (action.type === 'logux/unsubscribe') {\n        return\n      }\n      if (disconnected && meta.sync && meta.added) {\n        wait = true\n        update()\n      }\n    })\n  )\n\n  return () => {\n    for (let i of unbind) i()\n  }\n}\n","import { parseId } from '@logux/core'\n\nfunction bold(string) {\n  return '%c' + string + '%c'\n}\n\nfunction showLog(text, details) {\n  text = '%cLogux%c ' + text\n  let args = Array.from(text.match(/%c/g)).map((_, i) => {\n    if (i === 0) {\n      return 'color:#ffa200;font-weight:bold'\n    } else if (i % 2 === 0) {\n      return 'font-weight:bold'\n    } else {\n      return 'font-weight:normal'\n    }\n  })\n\n  if (details) {\n    console.groupCollapsed(text, ...args)\n    for (let name in details) {\n      if (typeof details[name] === 'string') {\n        console.log(name + ': %c' + details[name], 'font-weight:bold')\n      } else {\n        console.log(name, details[name])\n      }\n    }\n    console.groupEnd()\n  } else {\n    console.log(text, ...args)\n  }\n}\n\nexport function log(client, messages = {}) {\n  let node = client.node\n\n  let sent = {}\n  let unbind = []\n  let prevConnected = false\n\n  if (messages.state !== false) {\n    unbind.push(\n      client.on('state', () => {\n        let details\n        if (client.state === 'connecting' && node.connection.url) {\n          details = {\n            'Node ID': node.localNodeId,\n            'Server': node.connection.url\n          }\n        } else if (client.connected && !prevConnected && node.remoteNodeId) {\n          prevConnected = true\n          details = {\n            'Server ID': node.remoteNodeId\n          }\n        } else if (!client.connected) {\n          prevConnected = false\n        }\n        showLog('state is ' + bold(client.state), details)\n      })\n    )\n  }\n\n  if (messages.role !== false) {\n    unbind.push(\n      client.on('role', () => {\n        showLog('tab role is ' + bold(client.role))\n      })\n    )\n  }\n\n  let cleaned = {}\n  let ignore = (messages.ignoreActions || []).reduce((all, i) => {\n    all[i] = true\n    return all\n  }, {})\n\n  if (messages.add !== false) {\n    unbind.push(\n      client.on('add', (action, meta) => {\n        if (meta.tab && meta.tab !== client.tabId) return\n        if (ignore[action.type]) return\n        if (meta.sync) sent[meta.id] = action\n        let message\n        if (action.type === 'logux/subscribe') {\n          message = 'subscribing to ' + bold(action.channel) + ' channel'\n          if (Object.keys(action).length === 2) {\n            showLog(message)\n          } else {\n            showLog(message, { Action: action })\n          }\n        } else if (action.type === 'logux/subscribed') {\n          showLog(\n            'subscribed to ' + bold(action.channel) + ' channel by server'\n          )\n        } else if (action.type === 'logux/unsubscribe') {\n          message = 'unsubscribed from channel ' + bold(action.channel)\n          if (Object.keys(action).length === 2) {\n            showLog(message)\n          } else {\n            showLog(message, { Action: action })\n          }\n        } else if (action.type === 'logux/processed') {\n          if (sent[action.id]) {\n            let processed = sent[action.id]\n            let details = {\n              'Processed Action': processed\n            }\n            if (processed.type === 'logux/subscribe') {\n              showLog(\n                'subscribed to ' + bold(processed.channel) + ' channel',\n                details\n              )\n            } else {\n              showLog(\n                'action ' + bold(processed.type) + ' was processed',\n                details\n              )\n            }\n            delete sent[action.id]\n          } else {\n            showLog('action ' + bold(action.id) + ' was processed')\n          }\n        } else if (action.type === 'logux/undo') {\n          if (action.action.type === 'logux/subscribe') {\n            message = 'subscription to ' + bold(action.action.channel)\n          } else {\n            message = 'action ' + bold(action.action.type)\n          }\n          message += ' was undone because of ' + bold(action.reason)\n          let details = {\n            'Reverted Action': action.action\n          }\n          if (Object.keys(action).length > 4) {\n            details['Undo Action'] = action\n          }\n          if (sent[action.id]) {\n            delete sent[action.id]\n          }\n          showLog(message, details)\n        } else {\n          let details = { Action: action, Meta: meta }\n          message = 'added '\n          if (meta.reasons.length === 0) {\n            cleaned[meta.id] = true\n            message += 'and cleaned '\n          }\n          message += bold(action.type) + ' action'\n          let { nodeId } = parseId(meta.id)\n          if (nodeId !== node.localNodeId) {\n            details.From = nodeId\n          }\n          showLog(message, details)\n        }\n      })\n    )\n  }\n\n  if (messages.user !== false) {\n    unbind.push(\n      client.on('user', userId => {\n        let message = 'user ID was changed to ' + bold(userId)\n        showLog(message, { 'Node ID': client.nodeId })\n      })\n    )\n  }\n\n  if (messages.clean !== false) {\n    unbind.push(\n      client.on('clean', (action, meta) => {\n        if (cleaned[meta.id]) {\n          delete cleaned[meta.id]\n          return\n        }\n        if (meta.tab && meta.tab !== client.tabId) return\n        if (ignore[action.type]) return\n        if (action.type.startsWith('logux/')) return\n        let message = 'cleaned ' + bold(action.type) + ' action'\n        showLog(message, { Action: action, Meta: meta })\n      })\n    )\n  }\n\n  return () => {\n    for (let i of unbind) i()\n  }\n}\n","module.exports = require('./helpers/bundle-url').getBundleURL('jGf7V') + require('./helpers/bundle-manifest').resolve(\"9KQjq\");","module.exports = require('./helpers/bundle-url').getBundleURL('jGf7V') + require('./helpers/bundle-manifest').resolve(\"dVjUq\");","module.exports = require('./helpers/bundle-url').getBundleURL('jGf7V') + require('./helpers/bundle-manifest').resolve(\"gWDF8\");","module.exports = require('./helpers/bundle-url').getBundleURL('jGf7V') + require('./helpers/bundle-manifest').resolve(\"6EP5R\");","import refresh from './refresh.svg'\nimport success from './success.svg'\nimport offline from './offline.svg'\nimport error from './error.svg'\n\nexport let badgeStyles = {\n  base: {\n    position: 'fixed',\n    width: '15.4em',\n    height: '4em',\n    lineHeight: '1.4',\n    margin: '1.5em',\n    paddingLeft: '4.2em',\n    opacity: '0.8',\n    borderRadius: '0.4em',\n    color: '#fff',\n    fontFamily: 'Helvetica Neue, sans-serif',\n    zIndex: '999',\n    backgroundPosition: '1.2em center',\n    backgroundRepeat: 'no-repeat',\n    backgroundSize: '1.8em'\n  },\n  text: {\n    display: 'table-cell',\n    verticalAlign: 'middle',\n    height: '4em'\n  },\n  synchronized: {\n    backgroundColor: '#000',\n    backgroundImage: 'url(' + success + ')'\n  },\n  disconnected: {\n    backgroundColor: '#000',\n    backgroundImage: 'url(' + offline + ')'\n  },\n  wait: {\n    backgroundColor: '#000',\n    backgroundImage: 'url(' + offline + ')'\n  },\n  sending: {\n    backgroundColor: '#000',\n    backgroundImage: 'url(' + refresh + ')'\n  },\n  error: {\n    backgroundColor: '#F42A2A',\n    backgroundImage: 'url(' + error + ')'\n  },\n  protocolError: {\n    backgroundColor: '#000',\n    backgroundImage: 'url(' + refresh + ')'\n  }\n}\n","module.exports = require('./helpers/bundle-url').getBundleURL('jGf7V') + require('./helpers/bundle-manifest').resolve(\"d2JJm\");","module.exports = require('./helpers/bundle-url').getBundleURL('jGf7V') + require('./helpers/bundle-manifest').resolve(\"2YULu\");","module.exports = require('./helpers/bundle-url').getBundleURL('jGf7V') + require('./helpers/bundle-manifest').resolve(\"ht41N\");","import { MemoryStore, ClientNode, LocalPair, BaseNode, Log } from '@logux/core'\n\nimport {\n  CrossTabClient,\n  attention,\n  badgeEn,\n  confirm,\n  favicon,\n  status,\n  badge,\n  log\n} from '../../index.js'\nimport { badgeStyles } from '../../badge/styles/index.js'\nimport faviconOffline from './offline.png'\nimport faviconNormal from './normal.png'\nimport faviconError from './error.png'\n\nlet pair = new LocalPair(500)\n\nlet serverLog = new Log({\n  store: new MemoryStore(),\n  nodeId: 'server:uuid'\n})\nnew BaseNode('server:uuid', serverLog, pair.right)\n\nserverLog.on('add', (action, meta) => {\n  if (action.type !== 'logux/processed') {\n    setTimeout(() => {\n      serverLog.add({ type: 'logux/processed', id: meta.id })\n    }, 500)\n  }\n})\n\nlet client = new CrossTabClient({\n  subprotocol: location.hash.slice(1) || '1.0.0',\n  userId: '10',\n  server: 'wss://example.com/'\n})\n\nlet node = new ClientNode(client.node.localNodeId, client.log, pair.left)\nnode.connection.url = 'wss://example.com/'\nnode.emitter = client.node.emitter\nclient.node = node\n\nattention(client)\nconfirm(client)\nfavicon(client, {\n  normal: faviconNormal,\n  offline: faviconOffline,\n  error: faviconError\n})\nbadge(client, {\n  messages: badgeEn,\n  styles: badgeStyles\n})\nlog(client)\nstatus(client, s => {\n  document.all.status.innerText = s\n})\n\nlet count = 0\nfunction emoji(state) {\n  if (state === 'disconnected') {\n    return ''\n  } else if (state === 'connecting') {\n    return ''\n  } else {\n    return ''\n  }\n}\nfunction role(value) {\n  return value.slice(0, 1).toUpperCase()\n}\nfunction updateTitle() {\n  document.title = emoji(client.state) + ' ' + role(client.role) + ' ' + count\n}\n\nclient.on('state', () => {\n  document.all.connection.checked = client.connected\n  updateTitle()\n})\nclient.on('role', () => {\n  updateTitle()\n  document.all.connection.disabled = client.role !== 'leader'\n})\nclient.on('add', action => {\n  if (action.type === 'TICK') count++\n  updateTitle()\n})\nclient.on('clean', action => {\n  if (action.type === 'TICK') count--\n  updateTitle()\n})\n\nclient.log\n  .each(action => {\n    if (action.type === 'TICK') count++\n  })\n  .then(() => {\n    updateTitle()\n  })\n\nclient.on('role', () => {\n  let isLeader = client.role === 'leader'\n  document.all.connection.disabled = !isLeader\n  document.all.disabled.style.display = isLeader ? 'none' : 'inline'\n})\n\nclient.start()\n\ndocument.all.connection.onchange = e => {\n  if (e.target.checked) {\n    client.node.connection.connect()\n  } else {\n    client.node.connection.disconnect()\n  }\n}\n\ndocument.all.add.onclick = () => {\n  client.log.add({ type: 'TICK' }, { reasons: ['tick'], sync: true })\n}\n\ndocument.all.clean.onclick = () => {\n  client.log.removeReason('tick')\n}\n\ndocument.all.error.onclick = () => {\n  setTimeout(() => {\n    client.log.add({ type: 'logux/undo', reason: 'error' })\n  }, 3000)\n}\n\ndocument.all.denied.onclick = () => {\n  setTimeout(() => {\n    client.log.add({ type: 'logux/undo', reason: 'denied' })\n  }, 3000)\n}\n\ndocument.all.serverError.onclick = () => {\n  setTimeout(() => {\n    pair.right.send(['error', 'wrong-format'])\n  }, 3000)\n}\n\ndocument.all.subprotocolError.onclick = () => {\n  client.node.syncError('wrong-subprotocol', {\n    supported: '2.x',\n    used: '1.0.0'\n  })\n}\n\nif (client.options.subprotocol === '1.0.1') {\n  document.all.subprotocolClient.disabled = true\n} else {\n  document.all.subprotocolClient.onclick = () => {\n    window.open(location.toString() + '#1.0.1', '_blank')\n  }\n}\n","export function track(client, id) {\n  if (client.processing[id]) return client.processing[id][0]\n\n  let resolveCallback, rejectCallback\n  let promise = new Promise((resolve, reject) => {\n    resolveCallback = resolve\n    rejectCallback = reject\n  })\n  client.processing[id] = [promise, resolveCallback, rejectCallback]\n\n  return promise\n}\n","export function attention(client) {\n  let doc = document\n  let originTitle = false\n  let unbind = []\n  let timeout = false\n\n  let restoreTitle = () => {\n    if (originTitle) {\n      doc.title = originTitle\n      originTitle = false\n    }\n  }\n\n  let blink = () => {\n    if (doc.hidden && !originTitle) {\n      originTitle = doc.title\n      doc.title = '* ' + doc.title\n    } else {\n      restoreTitle()\n    }\n\n    if (doc.hidden) timeout = setTimeout(blink, 1000)\n  }\n\n  let tabListener = () => {\n    if (!doc.hidden && timeout) {\n      timeout = clearTimeout(timeout)\n      restoreTitle()\n    }\n  }\n\n  if (doc && typeof doc.hidden !== 'undefined') {\n    unbind.push(\n      client.node.on('error', error => {\n        if (error.type !== 'timeout' && !timeout) {\n          blink()\n        }\n      })\n    )\n\n    unbind.push(\n      client.on('add', action => {\n        if (action.type === 'logux/undo' && action.reason && !timeout) {\n          blink()\n        }\n      })\n    )\n\n    document.addEventListener('visibilitychange', tabListener, false)\n    unbind.push(() => {\n      document.removeEventListener('visibilitychange', tabListener, false)\n    })\n  }\n\n  return () => {\n    for (let i of unbind) i()\n  }\n}\n","export function favicon(client, links) {\n  let normal = links.normal\n  let offline = links.offline\n  let error = links.error\n\n  let unbind = []\n  let doc = document\n  let fav = false\n  let prevFav = false\n\n  function update() {\n    if (client.connected && prevFav !== normal) {\n      fav.href = prevFav = normal\n    } else if (\n      !client.connected &&\n      offline &&\n      prevFav !== offline &&\n      prevFav !== error\n    ) {\n      fav.href = prevFav = offline\n    }\n  }\n\n  function setError() {\n    if (error && prevFav !== error) {\n      fav.href = prevFav = error\n    }\n  }\n\n  if (doc) {\n    fav = doc.querySelector('link[rel~=\"icon\"]')\n\n    if (typeof normal === 'undefined') {\n      normal = fav ? fav.href : ''\n    }\n\n    if (!fav) {\n      fav = doc.createElement('link')\n      fav.rel = 'icon'\n      fav.href = ''\n      doc.head.appendChild(fav)\n    }\n\n    unbind.push(client.on('state', update))\n    update()\n\n    unbind.push(\n      client.on('add', action => {\n        if (action.type === 'logux/undo' && action.reason) setError()\n      })\n    )\n\n    unbind.push(\n      client.node.on('error', err => {\n        if (err.type !== 'timeout') setError()\n      })\n    )\n  }\n\n  return () => {\n    for (let i of unbind) i()\n  }\n}\n"],"names":["$19a2cc59e6683c15$export$6503ec6e8aabbaf","$19a2cc59e6683c15$export$f7ad0328861e2f03","$19a2cc59e6683c15$var$mapping","pairs","keys","Object","i","length","id","resolved","Error","$26e245d5b3a6c127$export$bdfd709ae4826697","$26e245d5b3a6c127$var$bundleURL","$26e245d5b3a6c127$var$getBaseURL","url","replace","value","err","matches","stack","match","$26e245d5b3a6c127$var$getBundleURL","parcelRequire","register","JSON","parse","$ffa423aa0ca41b46$export$c944a4526d4ed4f3","events","emit","event","args","this","forEach","on","cb","push","filter","$0937d5d07b5cf363$export$b283a0679303f4ba","emitter","action","meta","type","$0937d5d07b5cf363$export$ce30dbb46644d06c","listener","opts","newId","generateId","time","parseInt","reasons","keepLast","removeReason","olderThan","action2","store","byId","addedMeta","add","now","Date","lastTime","sequence","nodeId","each","callback","order","Promise","resolve","nextPage","get","result","page","entries","entry","next","bind","diff","k","remove","changeMeta","reason","criteria","$9664afd3939ba6e7$export$a5c06b7241b24c94","firstMeta","secondMeta","first","split","second","firstNode","secondNode","firstCounter","secondCounter","firstNodeTime","secondNodeTime","$b7d5b48a4a1b47fe$export$ea0df116fa892998","init","ws","onerror","error","onclose","onmessage","data","connect","Class","undefined","onopen","connected","disconnect","close","send","message","readyState","OPEN","stringify","received","WebSocket","$c249f35a8d1efa26$var$checkIndex","index","indexes","added","$c249f35a8d1efa26$var$forEachIndex","$c249f35a8d1efa26$var$isDefined","$c249f35a8d1efa26$var$insert","lastAdded","$c249f35a8d1efa26$var$eject","start","end","middle","otherAdded","splice","$c249f35a8d1efa26$var$find","list","$c249f35a8d1efa26$export$b72d712fed4d036d","otherMeta","indexList","j","findIndex","item","created","indexed","slice","key","removed","reasonPos","indexOf","c","youngerThan","minAdded","maxAdded","removedAdded","map","m","removing","includes","meta1","lastReceived","lastSent","sent","values","$faed749fe42b1a38$export$2abef671c5ad47c8","options","supported","used","super","name","description","describe","captureStackTrace","$294a7b062a64316c$var$auth","node","token","auth","authenticated","remoteHeaders","unauthenticated","onMessage","sendError","destroy","e","$294a7b062a64316c$var$checkProtocol","ver","remoteProtocol","minProtocol","$294a7b062a64316c$var$emitEvent","$e508ab408d8c23c8$var$NOT_TO_THROW","timeout","$e508ab408d8c23c8$var$BEFORE_AUTH","$e508ab408d8c23c8$var$syncMappedEvent","lastAddedCache","outMap","changed","sendSync","$e508ab408d8c23c8$export$410b0c854570d131","catch","throwsError","unbind","waitFor","state","connection","clearTimeout","pingTimeout","endTimeout","setLocalHeaders","headers","localHeaders","sendHeaders","msg","delayPing","onConnecting","setState","onConnect","onDisconnect","timeouts","outFilter","syncError","startTimeout","ms","setTimeout","shift","ping","sendPing","lastSynced","promises","log","then","r","all","syncSinceQuery","setLastSent","setLastSynced","setLastReceived","synced","getLastSynced","getLastAdded","initialized","sendDuilian","$e508ab408d8c23c8$var$DUILIANS","duilianMessage","line","remoteNodeId","remoteSubprotocol","localProtocol","localNodeId","timeFix","syncing","onAdd","initializing","initialize","prototype","sendConnect","subprotocol","fixTime","connectSended","sendConnected","connectMessage","baseTime","syncSince","connectedMessage","authTime","roundTrip","Math","floor","originMeta","unshift","concat","sendSynced","syncMessage","join","process","inMap","meta2","filtered","inFilter","res","syncedMessage","pingMessage","pongMessage","sendDebug","debugMessage","errorMessage","headersMessage","$f1e22745996b5789$var$DEFAULT_OPTIONS","$f1e22745996b5789$export$b4fa87e80e36ef61","$ab4e8d0dc1be1b3a$var$LocalConnection","other","pair","right","left","delay","$d9a91f2ca220917e$var$DEFAULT_OPTIONS","minDelay","maxDelay","attempts","Infinity","$d9a91f2ca220917e$var$FATAL_ERRORS","$d9a91f2ca220917e$export$495c43d07cb6ba9a","reconnecting","reconnect","nextDelay","timer","connecting","base","rand","random","deviation","min","visibility","document","hidden","navigator","onLine","window","addEventListener","removeEventListener","$afded42b0cc8605a$export$bf3b66d897b985f1","parts","userId","clientId","$381d0c76d494d1d2$export$471f7ae5c4103ae1","client","observable","disconnected","wait","old","duration","processing","setSynchronized","changeState","sync","$43ed9ae1624b5e4a$var$injectStyles","element","styles","style","$43ed9ae1624b5e4a$var$RESET","boxSizing","textIndent","textTransform","wordSpacing","letterSpacing","fontStyle","fontVariant","fontWeight","lineHeight","$dc671fad9cdb6b1f$export$ac4959f4f1338dfc","size","bytes","crypto","getRandomValues","Uint8Array","byte","toString","toUpperCase","$936f715570c45cc6$export$5e6967d3d1d0f8e8","$934683be227bc5f9$var$ALLOWED_META","$934683be227bc5f9$var$tabPing","localStorage","setItem","prefix","tabId","$934683be227bc5f9$var$cleanTabActions","isLocalStorage","removeItem","$3f4a150e2a2d6e8c$var$storageKey","$3f4a150e2a2d6e8c$var$sendToTabs","json","console","role","$3f4a150e2a2d6e8c$var$getLeader","getItem","$3f4a150e2a2d6e8c$var$leaderPing","$3f4a150e2a2d6e8c$var$onDeadLeader","$3f4a150e2a2d6e8c$var$setState","$3f4a150e2a2d6e8c$var$startElection","$3f4a150e2a2d6e8c$var$watchForLeader","watching","$3f4a150e2a2d6e8c$var$isActiveLeader","roleTimeout","$3f4a150e2a2d6e8c$var$setRole","leadership","setInterval","unloading","leaderPing","elections","clearInterval","leader","leaderTimeout","electionDelay","$92c221575bcb6155$var$block","returnValue","$b89f4eef5869bc81$var$bold","string","$b89f4eef5869bc81$var$showLog","text","details","Array","from","_","groupCollapsed","groupEnd","$3cc61fb9e7398e96$exports","getBundleURL","$5b8569871e293f9b$exports","$f6f7c732f8b6c2ec$exports","$462567230c63aba4$exports","$8ea0e945c1553d5f$export$92de9191ffb7ae9b","position","width","height","margin","paddingLeft","opacity","borderRadius","color","fontFamily","zIndex","backgroundPosition","backgroundRepeat","backgroundSize","display","verticalAlign","synchronized","backgroundColor","backgroundImage","$parcel$interopDefault","sending","protocolError","$a42ef8ec8b02ae02$exports","$628ec30626dd8e16$exports","$427a74adfebe3efa$exports","$d4931476f3d38f0e$var$pair","$d4931476f3d38f0e$var$serverLog","$d4931476f3d38f0e$var$client","cleanPrevActions","resolveCallback","rejectCallback","promise","reject","$a13a9584f86e1d87$export$6b2a7d5132615086","changeUser","wasConnected","getClientId","onUnload","pinging","clean","tabTimeout","lastId","nextLog","resubscribe","last","subscriptions","subscribing","unsubscribing","unsubscription","subscribers","subscription","channel","channels","tabPing","server","async","test","allowDangerousProtocol","unbindEnvTest","env","since","leaderState","onStorage","newValue","tab","isArray","compare","leftParts","rightParts","leftNumber","rightNumber","$3f4a150e2a2d6e8c$var$compareSubprotocols","subprotocolKey","location","hash","$d4931476f3d38f0e$var$node","doc","originTitle","restoreTitle","title","blink","tabListener","$a1bf8e76beec93ff$export$45b92471da762af7","update","$92c221575bcb6155$export$715f9d76bb8c1fea","links","normal","offline","fav","prevFav","href","setError","querySelector","createElement","rel","head","appendChild","$9140c3b5d7d1f5f6$export$d1d228f217d37317","messages","widget","setAttribute","top","transform","pos","$43ed9ae1624b5e4a$var$setPosition","show","innerHTML","denied","body","$43ed9ae1624b5e4a$export$4aebd143f31d0c0d","prevConnected","Server","cleaned","ignore","ignoreActions","reduce","Action","processed","Meta","From","user","startsWith","$b89f4eef5869bc81$export$bef1f36f5486a6a3","s","status","innerText","$d4931476f3d38f0e$var$count","$d4931476f3d38f0e$var$updateTitle","checked","disabled","isLeader","onchange","target","onclick","serverError","subprotocolError","subprotocolClient","open"],"version":3,"file":"index.dcbf1025.js.map"}