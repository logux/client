{"mappings":"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","sources":["./node_modules/@parcel/runtime-js/lib/bundle-manifest.js","./node_modules/@parcel/runtime-js/lib/JSRuntime.js","./node_modules/nanoevents/index.js","./node_modules/@logux/core/log/index.js","./node_modules/@logux/core/is-first-older/index.js","./node_modules/@logux/core/ws-connection/index.js","./node_modules/@logux/core/memory-store/index.js","./node_modules/@logux/core/logux-error/index.js","./node_modules/@logux/core/connect/index.js","./node_modules/@logux/core/base-node/index.js","./node_modules/@logux/core/sync/index.js","./node_modules/@logux/core/ping/index.js","./node_modules/@logux/core/debug/index.js","./node_modules/@logux/core/error/index.js","./node_modules/@logux/core/headers/index.js","./node_modules/@logux/core/client-node/index.js","./node_modules/@logux/core/local-pair/index.js","./node_modules/@logux/core/reconnect/index.js","./node_modules/@logux/core/parse-id/index.js","./status/index.js","./badge/index.js","./node_modules/nanoid/index.browser.js","./logux-undo-error/index.js","./client/index.js","./cross-tab-client/index.js","./confirm/index.js","./log/index.js","./node_modules/@parcel/runtime-js/lib/bundle-url.js","./node_modules/@parcel/runtime-js/lib/relative-path.js","./badge/styles/index.js","./test/demo/index.js","./track/index.js","./attention/index.js","./favicon/index.js"],"sourcesContent":["\"use strict\";\n\nvar mapping = {};\n\nfunction register(pairs) {\n  var keys = Object.keys(pairs);\n\n  for (var i = 0; i < keys.length; i++) {\n    mapping[keys[i]] = pairs[keys[i]];\n  }\n}\n\nfunction resolve(id) {\n  var resolved = mapping[id];\n\n  if (resolved == null) {\n    throw new Error('Could not resolve bundle with id ' + id);\n  }\n\n  return resolved;\n}\n\nmodule.exports.register = register;\nmodule.exports.resolve = resolve;","module.exports = require('./bundle-url').getBundleURL() + require('./relative-path')(\"1An09\", \"zln32\")","export let createNanoEvents = () => ({\n  events: {},\n  emit(event, ...args) {\n    ;(this.events[event] || []).forEach(i => i(...args))\n  },\n  on(event, cb) {\n    ;(this.events[event] = this.events[event] || []).push(cb)\n    return () =>\n      (this.events[event] = (this.events[event] || []).filter(i => i !== cb))\n  }\n})\n","import { createNanoEvents } from 'nanoevents'\n\nexport function actionEvents(emitter, event, action, meta) {\n  if (action.id) {\n    emitter.emit(`${event}-${action.type}-${action.id}`, action, meta)\n  }\n  emitter.emit(`${event}-${action.type}-`, action, meta)\n  emitter.emit(event, action, meta)\n}\n\nexport class Log {\n  constructor(opts = {}) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof opts.nodeId === 'undefined') {\n        throw new Error('Expected node ID')\n      }\n      if (typeof opts.store !== 'object') {\n        throw new Error('Expected store')\n      }\n      if (opts.nodeId.includes(' ')) {\n        throw new Error('Space is prohibited in node ID')\n      }\n    }\n\n    this.nodeId = opts.nodeId\n\n    this.lastTime = 0\n    this.sequence = 0\n\n    this.store = opts.store\n\n    this.emitter = createNanoEvents()\n  }\n\n  on(event, listener) {\n    return this.emitter.on(event, listener)\n  }\n\n  type(type, listener, opts = {}) {\n    let event = opts.event || 'add'\n    let id = opts.id || ''\n    return this.emitter.on(`${event}-${type}-${id}`, listener)\n  }\n\n  async add(action, meta = {}) {\n    if (typeof action.type === 'undefined') {\n      throw new Error('Expected \"type\" in action')\n    }\n\n    let newId = false\n    if (typeof meta.id === 'undefined') {\n      newId = true\n      meta.id = this.generateId()\n    }\n\n    if (typeof meta.time === 'undefined') {\n      meta.time = parseInt(meta.id)\n    }\n\n    if (typeof meta.reasons === 'undefined') {\n      meta.reasons = []\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (!Array.isArray(meta.reasons)) {\n        throw new Error('Expected \"reasons\" to be an array of strings')\n      }\n\n      for (let reason of meta.reasons) {\n        if (typeof reason !== 'string') {\n          throw new Error('Expected \"reasons\" to be an array of strings')\n        }\n      }\n\n      if (typeof meta.indexes !== 'undefined') {\n        if (!Array.isArray(meta.indexes)) {\n          throw new Error('Expected \"indexes\" to be an array of strings')\n        }\n\n        for (let index of meta.indexes) {\n          if (typeof index !== 'string') {\n            throw new Error('Expected \"indexes\" to be an array of strings')\n          }\n        }\n      }\n    }\n\n    actionEvents(this.emitter, 'preadd', action, meta)\n\n    if (meta.keepLast) {\n      this.removeReason(meta.keepLast, { olderThan: meta })\n      meta.reasons.push(meta.keepLast)\n    }\n\n    if (meta.reasons.length === 0 && newId) {\n      actionEvents(this.emitter, 'add', action, meta)\n      actionEvents(this.emitter, 'clean', action, meta)\n      return meta\n    } else if (meta.reasons.length === 0) {\n      let [action2] = await this.store.byId(meta.id)\n      if (action2) {\n        return false\n      } else {\n        actionEvents(this.emitter, 'add', action, meta)\n        actionEvents(this.emitter, 'clean', action, meta)\n        return meta\n      }\n    } else {\n      let addedMeta = await this.store.add(action, meta)\n      if (addedMeta === false) {\n        return false\n      } else {\n        actionEvents(this.emitter, 'add', action, meta)\n        return addedMeta\n      }\n    }\n  }\n\n  generateId() {\n    let now = Date.now()\n    if (now <= this.lastTime) {\n      now = this.lastTime\n      this.sequence += 1\n    } else {\n      this.lastTime = now\n      this.sequence = 0\n    }\n    return now + ' ' + this.nodeId + ' ' + this.sequence\n  }\n\n  each(opts, callback) {\n    if (!callback) {\n      callback = opts\n      opts = { order: 'created' }\n    }\n\n    let store = this.store\n    return new Promise(resolve => {\n      async function nextPage(get) {\n        let page = await get()\n        let result\n        for (let i = page.entries.length - 1; i >= 0; i--) {\n          let entry = page.entries[i]\n          result = callback(entry[0], entry[1])\n          if (result === false) break\n        }\n\n        if (result === false || !page.next) {\n          resolve()\n        } else {\n          nextPage(page.next)\n        }\n      }\n\n      nextPage(store.get.bind(store, opts))\n    })\n  }\n\n  async changeMeta(id, diff) {\n    for (let k in diff) {\n      if (\n        k === 'id' ||\n        k === 'added' ||\n        k === 'time' ||\n        k === 'subprotocol' ||\n        k === 'indexes'\n      ) {\n        throw new Error('Meta \"' + k + '\" is read-only')\n      }\n    }\n\n    if (diff.reasons && diff.reasons.length === 0) {\n      let entry = await this.store.remove(id)\n      if (entry) {\n        for (let k in diff) entry[1][k] = diff[k]\n        actionEvents(this.emitter, 'clean', entry[0], entry[1])\n      }\n      return !!entry\n    } else {\n      return this.store.changeMeta(id, diff)\n    }\n  }\n\n  removeReason(reason, criteria = {}) {\n    return this.store.removeReason(reason, criteria, (action, meta) => {\n      actionEvents(this.emitter, 'clean', action, meta)\n    })\n  }\n\n  byId(id) {\n    return this.store.byId(id)\n  }\n}\n","export function isFirstOlder(firstMeta, secondMeta) {\n  if (firstMeta && !secondMeta) {\n    return false\n  } else if (!firstMeta && secondMeta) {\n    return true\n  }\n\n  if (firstMeta.time > secondMeta.time) {\n    return false\n  } else if (firstMeta.time < secondMeta.time) {\n    return true\n  }\n\n  let first = firstMeta.id.split(' ')\n  let second = secondMeta.id.split(' ')\n\n  let firstNode = first[1]\n  let secondNode = second[1]\n  if (firstNode > secondNode) {\n    return false\n  } else if (firstNode < secondNode) {\n    return true\n  }\n\n  let firstCounter = parseInt(first[2])\n  let secondCounter = parseInt(second[2])\n  if (firstCounter > secondCounter) {\n    return false\n  } else if (firstCounter < secondCounter) {\n    return true\n  }\n\n  let firstNodeTime = parseInt(first[0])\n  let secondNodeTime = parseInt(second[0])\n  if (firstNodeTime > secondNodeTime) {\n    return false\n  } else if (firstNodeTime < secondNodeTime) {\n    return true\n  }\n\n  return false\n}\n","import { createNanoEvents } from 'nanoevents'\n\nexport class WsConnection {\n  constructor(url, Class, opts) {\n    this.connected = false\n    this.emitter = createNanoEvents()\n    if (Class) {\n      this.Class = Class\n    } else if (typeof WebSocket !== 'undefined') {\n      this.Class = WebSocket\n    } else {\n      throw new Error('No WebSocket support')\n    }\n    this.url = url\n    this.opts = opts\n  }\n\n  init(ws) {\n    ws.onerror = event => {\n      this.emitter.emit('error', event.error || new Error('WS Error'))\n    }\n\n    ws.onclose = () => {\n      this.onclose()\n    }\n\n    ws.onmessage = event => {\n      let data\n      try {\n        data = JSON.parse(event.data)\n      } catch {\n        this.error(event.data)\n        return\n      }\n      this.emitter.emit('message', data)\n    }\n\n    this.ws = ws\n  }\n\n  connect() {\n    if (this.ws) return Promise.resolve()\n\n    this.emitter.emit('connecting')\n    this.init(new this.Class(this.url, undefined, this.opts))\n\n    return new Promise(resolve => {\n      this.ws.onopen = () => {\n        this.connected = true\n        this.emitter.emit('connect')\n        resolve()\n      }\n    })\n  }\n\n  disconnect() {\n    if (this.ws) {\n      this.ws.onclose = undefined\n      this.ws.close()\n      this.onclose()\n    }\n  }\n\n  on(event, listener) {\n    return this.emitter.on(event, listener)\n  }\n\n  send(message) {\n    if (this.ws && this.ws.readyState === this.ws.OPEN) {\n      this.ws.send(JSON.stringify(message))\n    } else {\n      this.emitter.emit('error', new Error('WS was closed'))\n    }\n  }\n\n  error(message) {\n    let err = new Error('Wrong message format')\n    err.received = message\n    this.emitter.emit('error', err)\n  }\n\n  onclose() {\n    if (this.ws) {\n      this.connected = false\n      this.emitter.emit('disconnect')\n      this.ws = undefined\n    }\n  }\n}\n","import { isFirstOlder } from '../is-first-older/index.js'\n\nfunction checkIndex(store, index) {\n  if (!store.indexes[index]) {\n    store.indexes[index] = { added: [], entries: [] }\n  }\n}\n\nfunction forEachIndex(meta, cb) {\n  let indexes = meta.indexes\n  if (isDefined(indexes) && indexes.length > 0) {\n    for (let index of indexes) {\n      cb(index)\n    }\n  }\n}\n\nfunction insert(store, entry) {\n  store.lastAdded += 1\n  entry[1].added = store.lastAdded\n  store.added.push(entry)\n  forEachIndex(entry[1], index => {\n    checkIndex(store, index)\n    store.indexes[index].added.push(entry)\n  })\n  return Promise.resolve(entry[1])\n}\n\nfunction eject(store, meta) {\n  let added = meta.added\n  let start = 0\n  let end = store.added.length - 1\n  while (start <= end) {\n    let middle = (end + start) >> 1\n    let otherAdded = store.added[middle][1].added\n    if (otherAdded < added) {\n      start = middle + 1\n    } else if (otherAdded > added) {\n      end = middle - 1\n    } else {\n      store.added.splice(middle, 1)\n      break\n    }\n  }\n}\n\nfunction find(list, id) {\n  for (let i = list.length - 1; i >= 0; i--) {\n    if (id === list[i][1].id) {\n      return i\n    }\n  }\n  return -1\n}\n\nfunction isDefined(value) {\n  return typeof value !== 'undefined'\n}\n\nexport class MemoryStore {\n  constructor() {\n    this.entries = []\n    this.added = []\n    this.indexes = {}\n    this.lastReceived = 0\n    this.lastAdded = 0\n    this.lastSent = 0\n  }\n\n  async add(action, meta) {\n    let entry = [action, meta]\n    let id = meta.id\n\n    let list = this.entries\n    for (let i = 0; i < list.length; i++) {\n      let [, otherMeta] = list[i]\n      if (id === otherMeta.id) {\n        return false\n      } else if (!isFirstOlder(otherMeta, meta)) {\n        forEachIndex(meta, index => {\n          checkIndex(this, index)\n          let indexList = this.indexes[index].entries\n          let j = indexList.findIndex(item => !isFirstOlder(item[1], meta))\n          indexList.splice(j, 0, entry)\n        })\n        list.splice(i, 0, entry)\n        return insert(this, entry)\n      }\n    }\n\n    forEachIndex(meta, index => {\n      checkIndex(this, index)\n      this.indexes[index].entries.push(entry)\n    })\n    list.push(entry)\n    return insert(this, entry)\n  }\n\n  async byId(id) {\n    let created = find(this.entries, id)\n    if (created === -1) {\n      return [null, null]\n    } else {\n      let [action, meta] = this.entries[created]\n      return [action, meta]\n    }\n  }\n\n  async remove(id, created) {\n    if (typeof created === 'undefined') {\n      created = find(this.entries, id)\n      if (created === -1) return Promise.resolve(false)\n    }\n\n    let entry = [this.entries[created][0], this.entries[created][1]]\n    forEachIndex(entry[1], index => {\n      let entries = this.indexes[index].entries\n      let indexed = find(entries, id)\n      if (indexed !== -1) entries.splice(indexed, 1)\n    })\n    this.entries.splice(created, 1)\n\n    forEachIndex(entry[1], index => {\n      eject(this.indexes[index], entry[1])\n    })\n    eject(this, entry[1])\n\n    return entry\n  }\n\n  async get(opts = {}) {\n    let index = opts.index\n    let store = this\n    let entries\n    if (index) {\n      store = this.indexes[index] || { added: [], entries: [] }\n    }\n    if (opts.order === 'created') {\n      entries = store.entries\n    } else {\n      entries = store.added\n    }\n    return { entries: entries.slice(0) }\n  }\n\n  async changeMeta(id, diff) {\n    let index = find(this.entries, id)\n    if (index === -1) {\n      return false\n    } else {\n      let meta = this.entries[index][1]\n      for (let key in diff) meta[key] = diff[key]\n      return true\n    }\n  }\n\n  async removeReason(reason, criteria, callback) {\n    let removed = []\n\n    if (criteria.id) {\n      let index = find(this.entries, criteria.id)\n      if (index !== -1) {\n        let meta = this.entries[index][1]\n        let reasonPos = meta.reasons.indexOf(reason)\n        if (reasonPos !== -1) {\n          meta.reasons.splice(reasonPos, 1)\n          if (meta.reasons.length === 0) {\n            callback(this.entries[index][0], meta)\n            this.remove(criteria.id)\n          }\n        }\n      }\n    } else {\n      this.entries = this.entries.filter(([action, meta]) => {\n        let c = criteria\n\n        let reasonPos = meta.reasons.indexOf(reason)\n        if (reasonPos === -1) {\n          return true\n        }\n        if (isDefined(c.olderThan) && !isFirstOlder(meta, c.olderThan)) {\n          return true\n        }\n        if (isDefined(c.youngerThan) && !isFirstOlder(c.youngerThan, meta)) {\n          return true\n        }\n        if (isDefined(c.minAdded) && meta.added < c.minAdded) {\n          return true\n        }\n        if (isDefined(c.maxAdded) && meta.added > c.maxAdded) {\n          return true\n        }\n\n        meta.reasons.splice(reasonPos, 1)\n        if (meta.reasons.length === 0) {\n          callback(action, meta)\n          removed.push(meta)\n          return false\n        } else {\n          return true\n        }\n      })\n\n      let removedAdded = removed.map(m => m.added)\n      let removing = i => !removedAdded.includes(i[1].added)\n      this.added = this.added.filter(removing)\n\n      for (let meta of removed) {\n        forEachIndex(meta, i => {\n          this.indexes[i].entries = this.indexes[i].entries.filter(removing)\n          this.indexes[i].added = this.indexes[i].added.filter(removing)\n        })\n      }\n    }\n  }\n\n  async clean() {\n    this.entries = []\n    this.added = []\n    this.indexes = {}\n    this.lastReceived = 0\n    this.lastAdded = 0\n    this.lastSent = 0\n  }\n\n  async getLastAdded() {\n    return this.lastAdded\n  }\n\n  async getLastSynced() {\n    return {\n      received: this.lastReceived,\n      sent: this.lastSent\n    }\n  }\n\n  async setLastSynced(values) {\n    if (typeof values.sent !== 'undefined') {\n      this.lastSent = values.sent\n    }\n    if (typeof values.received !== 'undefined') {\n      this.lastReceived = values.received\n    }\n  }\n}\n","export class LoguxError extends Error {\n  static describe(type, options) {\n    if (type === 'timeout') {\n      return 'A timeout was reached (' + options + ' ms)'\n    } else if (type === 'wrong-format') {\n      return 'Wrong message format in ' + options\n    } else if (type === 'unknown-message') {\n      return 'Unknown message `' + options + '` type'\n    } else if (type === 'bruteforce') {\n      return 'Too many wrong authentication attempts'\n    } else if (type === 'wrong-protocol') {\n      return (\n        `Logux supports protocols only from version ${options.supported}` +\n        `, but you use ${options.used}`\n      )\n    } else if (type === 'wrong-subprotocol') {\n      return (\n        `Only ${options.supported} application subprotocols are ` +\n        `supported, but you use ${options.used}`\n      )\n    } else if (type === 'wrong-credentials') {\n      return 'Wrong credentials'\n    } else {\n      return type\n    }\n  }\n\n  constructor(type, options, received) {\n    super(type)\n    this.name = 'LoguxError'\n    this.type = type\n    this.options = options\n    this.description = LoguxError.describe(type, options)\n    this.received = !!received\n\n    if (received) {\n      this.message = 'Logux received ' + this.type + ' error'\n      if (this.description !== this.type) {\n        this.message += ' (' + this.description + ')'\n      }\n    } else {\n      this.message = this.description\n    }\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, LoguxError)\n    }\n  }\n}\n","import { LoguxError } from '../logux-error/index.js'\n\nasync function auth(node, nodeId, token, callback) {\n  if (!node.options.auth) {\n    node.authenticated = true\n    callback()\n    return\n  }\n\n  try {\n    let access = await node.options.auth(nodeId, token, node.remoteHeaders)\n    if (access) {\n      node.authenticated = true\n      callback()\n      for (let i = 0; i < node.unauthenticated.length; i++) {\n        node.onMessage(node.unauthenticated[i])\n      }\n      node.unauthenticated = []\n    } else {\n      node.sendError(new LoguxError('wrong-credentials'))\n      node.destroy()\n    }\n  } catch (e) {\n    if (e.name === 'LoguxError') {\n      node.sendError(e)\n      node.destroy()\n    } else {\n      node.error(e)\n    }\n  }\n}\n\nfunction checkProtocol(node, ver) {\n  node.remoteProtocol = ver\n\n  if (ver >= node.minProtocol) {\n    return true\n  } else {\n    node.sendError(\n      new LoguxError('wrong-protocol', {\n        supported: node.minProtocol,\n        used: ver\n      })\n    )\n    node.destroy()\n    return false\n  }\n}\n\nfunction emitEvent(node) {\n  try {\n    node.emitter.emit('connect')\n  } catch (e) {\n    if (e.name === 'LoguxError') {\n      node.sendError(e)\n      return false\n    } else {\n      throw e\n    }\n  }\n  return true\n}\n\nexport async function sendConnect() {\n  let message = [\n    'connect',\n    this.localProtocol,\n    this.localNodeId,\n    this.lastReceived\n  ]\n\n  let options = {}\n  if (this.options.token) {\n    if (typeof this.options.token === 'function') {\n      options.token = await this.options.token()\n    } else {\n      options.token = this.options.token\n    }\n  }\n  if (this.options.subprotocol) {\n    options.subprotocol = this.options.subprotocol\n  }\n  if (Object.keys(options).length > 0) message.push(options)\n\n  if (this.options.fixTime) this.connectSended = this.now()\n\n  if (Object.keys(this.localHeaders).length > 0) {\n    this.sendHeaders(this.localHeaders)\n  }\n\n  this.startTimeout()\n  this.send(message)\n}\n\nexport async function sendConnected(start, end) {\n  let message = [\n    'connected',\n    this.localProtocol,\n    this.localNodeId,\n    [start, end]\n  ]\n\n  let options = {}\n  if (this.options.token) {\n    if (typeof this.options.token === 'function') {\n      options.token = await this.options.token()\n    } else {\n      options.token = this.options.token\n    }\n  }\n  if (this.options.subprotocol) {\n    options.subprotocol = this.options.subprotocol\n  }\n  if (Object.keys(options).length > 0) message.push(options)\n\n  if (Object.keys(this.localHeaders).length > 0) {\n    this.sendHeaders(this.localHeaders)\n  }\n\n  this.send(message)\n}\n\nexport function connectMessage(ver, nodeId, synced, options) {\n  let start = this.now()\n  if (!options) options = {}\n\n  this.remoteNodeId = nodeId\n  if (!checkProtocol(this, ver)) return\n\n  this.remoteSubprotocol = options.subprotocol || '0.0.0'\n\n  if (!emitEvent(this)) {\n    this.destroy()\n    return\n  }\n\n  auth(this, nodeId, options.token, () => {\n    this.baseTime = this.now()\n    this.sendConnected(start, this.baseTime)\n    this.syncSince(synced)\n  })\n}\n\nexport function connectedMessage(ver, nodeId, time, options) {\n  if (!options) options = {}\n\n  this.endTimeout()\n  this.remoteNodeId = nodeId\n  if (!checkProtocol(this, ver)) return\n\n  this.baseTime = time[1]\n\n  if (this.options.fixTime) {\n    let now = this.now()\n    let authTime = time[1] - time[0]\n    let roundTrip = now - this.connectSended - authTime\n    this.timeFix = Math.floor(this.connectSended - time[0] + roundTrip / 2)\n  }\n\n  this.remoteSubprotocol = options.subprotocol || '0.0.0'\n\n  if (!emitEvent(this)) {\n    this.destroy()\n    return\n  }\n\n  auth(this, nodeId, options.token, () => {\n    this.syncSince(this.lastSent)\n  })\n}\n","import { createNanoEvents } from 'nanoevents'\n\nimport {\n  sendConnect,\n  sendConnected,\n  connectMessage,\n  connectedMessage\n} from '../connect/index.js'\nimport {\n  syncedMessage,\n  syncMessage,\n  sendSynced,\n  sendSync\n} from '../sync/index.js'\nimport { sendPing, pingMessage, pongMessage } from '../ping/index.js'\nimport { sendHeaders, headersMessage } from '../headers/index.js'\nimport { sendDebug, debugMessage } from '../debug/index.js'\nimport { sendError, errorMessage } from '../error/index.js'\nimport { LoguxError } from '../logux-error/index.js'\n\nconst NOT_TO_THROW = {\n  'wrong-subprotocol': true,\n  'wrong-protocol': true,\n  'timeout': true\n}\n\nconst BEFORE_AUTH = ['connect', 'connected', 'error', 'debug', 'headers']\n\nasync function syncMappedEvent(node, action, meta) {\n  let added = meta.added\n  if (typeof added === 'undefined') {\n    let lastAdded = node.lastAddedCache\n    added = lastAdded > node.lastSent ? lastAdded : node.lastSent\n  }\n  if (node.options.outMap) {\n    try {\n      let changed = await node.options.outMap(action, meta)\n      node.sendSync(added, [changed])\n    } catch (e) {\n      node.error(e)\n    }\n  } else {\n    node.sendSync(added, [[action, meta]])\n  }\n}\n\nexport class BaseNode {\n  constructor(nodeId, log, connection, options = {}) {\n    this.remoteNodeId = undefined\n    this.remoteProtocol = undefined\n    this.remoteSubprotocol = undefined\n\n    this.minProtocol = 3\n    this.localProtocol = 4\n    this.localNodeId = nodeId\n\n    this.log = log\n    this.connection = connection\n    this.options = options\n\n    if (this.options.ping && !this.options.timeout) {\n      throw new Error('You must set timeout option to use ping')\n    }\n\n    this.connected = false\n    this.authenticated = false\n    this.unauthenticated = []\n\n    this.timeFix = 0\n    this.syncing = 0\n    this.received = {}\n\n    this.lastSent = 0\n    this.lastReceived = 0\n\n    this.state = 'disconnected'\n\n    this.emitter = createNanoEvents()\n    this.timeouts = []\n    this.throwsError = true\n\n    this.unbind = [\n      log.on('add', (action, meta) => {\n        this.onAdd(action, meta)\n      }),\n      connection.on('connecting', () => {\n        this.onConnecting()\n      }),\n      connection.on('connect', () => {\n        this.onConnect()\n      }),\n      connection.on('message', message => {\n        this.onMessage(message)\n      }),\n      connection.on('error', error => {\n        if (error.message === 'Wrong message format') {\n          this.sendError(new LoguxError('wrong-format', error.received))\n          this.connection.disconnect('error')\n        } else {\n          this.error(error)\n        }\n      }),\n      connection.on('disconnect', () => {\n        this.onDisconnect()\n      })\n    ]\n\n    this.initialized = false\n    this.lastAddedCache = 0\n    this.initializing = this.initialize()\n    this.localHeaders = {}\n    this.remoteHeaders = {}\n  }\n\n  on(event, listener) {\n    return this.emitter.on(event, listener)\n  }\n\n  catch(listener) {\n    this.throwsError = false\n    let unbind = this.on('error', listener)\n    return () => {\n      this.throwsError = true\n      unbind()\n    }\n  }\n\n  waitFor(state) {\n    if (this.state === state) {\n      return Promise.resolve()\n    }\n    return new Promise(resolve => {\n      let unbind = this.on('state', () => {\n        if (this.state === state) {\n          unbind()\n          resolve()\n        }\n      })\n    })\n  }\n\n  destroy() {\n    if (this.connection.destroy) {\n      this.connection.destroy()\n    } else if (this.connected) {\n      this.connection.disconnect('destroy')\n    }\n    for (let i of this.unbind) i()\n    clearTimeout(this.pingTimeout)\n    this.endTimeout()\n  }\n\n  setLocalHeaders(headers) {\n    this.localHeaders = headers\n    if (this.connected) {\n      this.sendHeaders(headers)\n    }\n  }\n\n  send(msg) {\n    if (!this.connected) return\n    this.delayPing()\n    try {\n      this.connection.send(msg)\n    } catch (e) {\n      this.error(e)\n    }\n  }\n\n  onConnecting() {\n    this.setState('connecting')\n  }\n\n  onConnect() {\n    this.delayPing()\n    this.connected = true\n  }\n\n  onDisconnect() {\n    while (this.timeouts.length > 0) {\n      this.endTimeout()\n    }\n    if (this.pingTimeout) clearTimeout(this.pingTimeout)\n    this.authenticated = false\n    this.connected = false\n    this.setState('disconnected')\n  }\n\n  onMessage(msg) {\n    this.delayPing()\n    let name = msg[0]\n\n    if (!this.authenticated && !BEFORE_AUTH.includes(name)) {\n      this.unauthenticated.push(msg)\n      return\n    }\n\n    this[name + 'Message'](...msg.slice(1))\n  }\n\n  async onAdd(action, meta) {\n    if (!this.authenticated) return\n    if (this.lastAddedCache < meta.added) {\n      this.lastAddedCache = meta.added\n    }\n\n    if (this.received && this.received[meta.id]) {\n      delete this.received[meta.id]\n      return\n    }\n\n    if (this.options.outFilter) {\n      try {\n        let result = await this.options.outFilter(action, meta)\n        if (result) syncMappedEvent(this, action, meta)\n      } catch (e) {\n        this.error(e)\n      }\n    } else {\n      syncMappedEvent(this, action, meta)\n    }\n  }\n\n  syncError(type, options, received) {\n    let err = new LoguxError(type, options, received)\n    this.emitter.emit('error', err)\n    if (!NOT_TO_THROW[type] && this.throwsError) {\n      throw err\n    }\n  }\n\n  error(err) {\n    this.emitter.emit('error', err)\n    this.connection.disconnect('error')\n    if (this.throwsError) {\n      throw err\n    }\n  }\n\n  setState(state) {\n    if (this.state !== state) {\n      this.state = state\n      this.emitter.emit('state')\n    }\n  }\n\n  startTimeout() {\n    if (!this.options.timeout) return\n\n    let ms = this.options.timeout\n    let timeout = setTimeout(() => {\n      if (this.connected) this.connection.disconnect('timeout')\n      this.syncError('timeout', ms)\n    }, ms)\n\n    this.timeouts.push(timeout)\n  }\n\n  endTimeout() {\n    if (this.timeouts.length > 0) {\n      clearTimeout(this.timeouts.shift())\n    }\n  }\n\n  delayPing() {\n    if (!this.options.ping) return\n    if (this.pingTimeout) clearTimeout(this.pingTimeout)\n\n    this.pingTimeout = setTimeout(() => {\n      if (this.connected && this.authenticated) this.sendPing()\n    }, this.options.ping)\n  }\n\n  async syncSinceQuery(lastSynced) {\n    let promises = []\n    await this.log.each({ order: 'added' }, (action, meta) => {\n      if (meta.added <= lastSynced) return false\n      if (this.options.outFilter) {\n        promises.push(\n          this.options\n            .outFilter(action, meta)\n            .then(r => {\n              if (r) {\n                return [action, meta]\n              } else {\n                return false\n              }\n            })\n            .catch(e => {\n              this.error(e)\n            })\n        )\n      } else {\n        promises.push(Promise.resolve([action, meta]))\n      }\n      return true\n    })\n\n    let entries = await Promise.all(promises)\n\n    let data = { added: 0 }\n    data.entries = entries.filter(entry => {\n      if (entry && data.added < entry[1].added) {\n        data.added = entry[1].added\n      }\n      return entry !== false\n    })\n    return data\n  }\n\n  async syncSince(lastSynced) {\n    let data = await this.syncSinceQuery(lastSynced)\n    if (!this.connected) return\n    if (data.entries.length > 0) {\n      if (this.options.outMap) {\n        Promise.all(\n          data.entries.map(i => {\n            return this.options.outMap(i[0], i[1])\n          })\n        )\n          .then(changed => {\n            this.sendSync(data.added, changed)\n          })\n          .catch(e => {\n            this.error(e)\n          })\n      } else {\n        this.sendSync(data.added, data.entries)\n      }\n    } else {\n      this.setState('synchronized')\n    }\n  }\n\n  setLastSent(value) {\n    if (this.lastSent < value) {\n      this.lastSent = value\n      this.log.store.setLastSynced({ sent: value })\n    }\n  }\n\n  setLastReceived(value) {\n    if (this.lastReceived < value) this.lastReceived = value\n    this.log.store.setLastSynced({ received: value })\n  }\n\n  now() {\n    return Date.now()\n  }\n\n  async initialize() {\n    let [synced, added] = await Promise.all([\n      this.log.store.getLastSynced(),\n      this.log.store.getLastAdded()\n    ])\n    this.initialized = true\n    this.lastSent = synced.sent\n    this.lastReceived = synced.received\n    this.lastAddedCache = added\n    if (this.connection.connected) this.onConnect()\n  }\n\n  sendDuilian() {\n    this.send(['duilian', Object.keys(DUILIANS)[0]])\n  }\n\n  duilianMessage(line) {\n    if (DUILIANS[line]) {\n      this.send(['duilian', DUILIANS[line]])\n    }\n  }\n}\n\nBaseNode.prototype.sendConnect = sendConnect\nBaseNode.prototype.sendConnected = sendConnected\nBaseNode.prototype.connectMessage = connectMessage\nBaseNode.prototype.connectedMessage = connectedMessage\n\nBaseNode.prototype.sendSync = sendSync\nBaseNode.prototype.sendSynced = sendSynced\nBaseNode.prototype.syncMessage = syncMessage\nBaseNode.prototype.syncedMessage = syncedMessage\n\nBaseNode.prototype.sendPing = sendPing\nBaseNode.prototype.pingMessage = pingMessage\nBaseNode.prototype.pongMessage = pongMessage\n\nBaseNode.prototype.sendDebug = sendDebug\nBaseNode.prototype.debugMessage = debugMessage\n\nBaseNode.prototype.sendError = sendError\nBaseNode.prototype.errorMessage = errorMessage\n\nBaseNode.prototype.sendHeaders = sendHeaders\nBaseNode.prototype.headersMessage = headersMessage\n\nconst DUILIANS = {\n  : ''\n}\n","export function sendSync(added, entries) {\n  this.startTimeout()\n\n  let data = []\n  for (let [action, originMeta] of entries) {\n    let meta = {}\n    for (let key in originMeta) {\n      if (key === 'id') {\n        meta.id = originMeta.id.split(' ')\n      } else if (key !== 'added') {\n        meta[key] = originMeta[key]\n      }\n    }\n\n    if (this.timeFix) meta.time -= this.timeFix\n    meta.id[0] = parseInt(meta.id[0]) - this.baseTime\n    meta.id[2] = parseInt(meta.id[2])\n    meta.time -= this.baseTime\n\n    if (meta.id[1] === this.localNodeId) {\n      if (meta.id[2] === 0) {\n        meta.id = meta.id[0]\n      } else {\n        meta.id = [meta.id[0], meta.id[2]]\n      }\n    }\n\n    data.unshift(action, meta)\n  }\n\n  this.syncing += 1\n  this.setState('sending')\n  this.send(['sync', added].concat(data))\n}\n\nexport function sendSynced(added) {\n  this.send(['synced', added])\n}\n\nexport async function syncMessage(added, ...data) {\n  let promises = []\n\n  for (let i = 0; i < data.length - 1; i += 2) {\n    let action = data[i]\n    let meta = data[i + 1]\n\n    if (typeof meta.id === 'number') {\n      meta.id = meta.id + this.baseTime + ' ' + this.remoteNodeId + ' ' + 0\n    } else {\n      meta.id[0] = meta.id[0] + this.baseTime\n      if (meta.id.length === 2) {\n        meta.id = meta.id[0] + ' ' + this.remoteNodeId + ' ' + meta.id[1]\n      } else {\n        meta.id = meta.id.join(' ')\n      }\n    }\n\n    meta.time = meta.time + this.baseTime\n    if (this.timeFix) meta.time = meta.time + this.timeFix\n\n    let process = Promise.resolve([action, meta])\n\n    if (this.options.inMap) {\n      process = process\n        .then(([action2, meta2]) => {\n          return this.options.inMap(action2, meta2)\n        })\n        .catch(e => {\n          this.error(e)\n        })\n    }\n\n    process\n      .then(filtered => {\n        if (filtered && this.options.inFilter) {\n          return this.options\n            .inFilter(...filtered)\n            .then(res => {\n              return res ? filtered : false\n            })\n            .catch(e => {\n              this.error(e)\n            })\n        } else {\n          return filtered\n        }\n      })\n      .then(changed => {\n        if (!changed) return false\n        if (this.received) this.received[changed[1].id] = true\n        return this.log.add(changed[0], changed[1])\n      })\n\n    promises.push(process)\n  }\n\n  await Promise.all(promises)\n  this.setLastReceived(added)\n  this.sendSynced(added)\n}\n\nexport function syncedMessage(synced) {\n  this.endTimeout()\n  this.setLastSent(synced)\n  if (this.syncing > 0) this.syncing -= 1\n  if (this.syncing === 0) {\n    this.setState('synchronized')\n  }\n}\n","export function sendPing() {\n  this.startTimeout()\n  this.send(['ping', this.lastAddedCache])\n  if (this.pingTimeout) clearTimeout(this.pingTimeout)\n}\n\nexport function pingMessage(synced) {\n  this.setLastReceived(synced)\n  if (this.connected && this.authenticated) {\n    this.send(['pong', this.lastAddedCache])\n  }\n}\n\nexport function pongMessage(synced) {\n  this.setLastReceived(synced)\n  this.endTimeout()\n}\n","export function sendDebug(type, data) {\n  this.send(['debug', type, data])\n}\n\nexport function debugMessage(type, data) {\n  this.emitter.emit('debug', type, data)\n}\n","export function sendError(error) {\n  let message = ['error', error.type]\n  if (typeof error.options !== 'undefined') message.push(error.options)\n  this.send(message)\n\n  this.emitter.emit('clientError', error)\n}\n\nexport function errorMessage(type, options) {\n  this.syncError(type, options, true)\n}\n","export function sendHeaders(data) {\n  this.send(['headers', data])\n}\n\nexport function headersMessage(data) {\n  this.remoteHeaders = data\n  this.emitter.emit('headers', data)\n}\n","import { BaseNode } from '../base-node/index.js'\n\nconst DEFAULT_OPTIONS = {\n  fixTime: true,\n  timeout: 20000,\n  ping: 5000\n}\n\nexport class ClientNode extends BaseNode {\n  constructor(nodeId, log, connection, options = {}) {\n    options = { ...DEFAULT_OPTIONS, ...options }\n    super(nodeId, log, connection, options)\n  }\n\n  onConnect() {\n    if (!this.connected) {\n      this.connected = true\n      this.initializing = this.initializing.then(() => {\n        if (this.connected) this.sendConnect()\n      })\n    }\n  }\n}\n","import { createNanoEvents } from 'nanoevents'\n\nclass LocalConnection {\n  constructor(pair, type) {\n    this.connected = false\n    this.emitter = createNanoEvents()\n    this.type = type\n    this.pair = pair\n  }\n\n  other() {\n    if (this.type === 'left') {\n      return this.pair.right\n    } else {\n      return this.pair.left\n    }\n  }\n\n  on(event, listener) {\n    return this.emitter.on(event, listener)\n  }\n\n  connect() {\n    if (this.connected) {\n      throw new Error('Connection already established')\n    } else {\n      this.emitter.emit('connecting')\n      return new Promise(resolve => {\n        setTimeout(() => {\n          this.other().connected = true\n          this.connected = true\n          this.other().emitter.emit('connect')\n          this.emitter.emit('connect')\n          resolve()\n        }, this.pair.delay)\n      })\n    }\n  }\n\n  disconnect(reason) {\n    if (!this.connected) {\n      throw new Error('Connection already finished')\n    } else {\n      this.connected = false\n      this.emitter.emit('disconnect', reason)\n      return new Promise(resolve => {\n        setTimeout(() => {\n          this.other().connected = false\n          this.other().emitter.emit('disconnect')\n          resolve()\n        }, 1)\n      })\n    }\n  }\n\n  send(message) {\n    if (this.connected) {\n      setTimeout(() => {\n        this.other().emitter.emit('message', message)\n      }, this.pair.delay)\n    } else {\n      throw new Error('Connection should be started before sending a message')\n    }\n  }\n}\n\nexport class LocalPair {\n  constructor(delay = 1) {\n    this.delay = delay\n    this.left = new LocalConnection(this, 'left')\n    this.right = new LocalConnection(this, 'right')\n  }\n}\n","const DEFAULT_OPTIONS = {\n  minDelay: 1000,\n  maxDelay: 5000,\n  attempts: Infinity\n}\n\nconst FATAL_ERRORS = [\n  'wrong-protocol',\n  'wrong-subprotocol',\n  'wrong-credentials'\n]\n\nexport class Reconnect {\n  constructor(connection, options = {}) {\n    this.connection = connection\n    this.options = { ...DEFAULT_OPTIONS, ...options }\n\n    this.reconnecting = connection.connected\n    this.connecting = false\n    this.attempts = 0\n\n    this.unbind = [\n      this.connection.on('message', msg => {\n        if (msg[0] === 'error' && FATAL_ERRORS.includes(msg[1])) {\n          this.reconnecting = false\n        }\n      }),\n      this.connection.on('connecting', () => {\n        this.connecting = true\n      }),\n      this.connection.on('connect', () => {\n        this.attempts = 0\n        this.connecting = false\n      }),\n      this.connection.on('disconnect', () => {\n        this.connecting = false\n        if (this.reconnecting) this.reconnect()\n      }),\n      () => {\n        clearTimeout(this.timer)\n      }\n    ]\n\n    let visibility = () => {\n      if (this.reconnecting && !this.connected && !this.connecting) {\n        if (typeof document !== 'undefined' && !document.hidden) this.connect()\n      }\n    }\n    let connect = () => {\n      if (this.reconnecting && !this.connected && !this.connecting) {\n        if (navigator.onLine) this.connect()\n      }\n    }\n    let disconnect = () => {\n      this.disconnect('freeze')\n    }\n    if (\n      typeof document !== 'undefined' &&\n      typeof window !== 'undefined' &&\n      document.addEventListener &&\n      window.addEventListener\n    ) {\n      document.addEventListener('visibilitychange', visibility, false)\n      window.addEventListener('focus', connect, false)\n      window.addEventListener('online', connect, false)\n      window.addEventListener('resume', connect, false)\n      window.addEventListener('freeze', disconnect, false)\n      this.unbind.push(() => {\n        document.removeEventListener('visibilitychange', visibility, false)\n        window.removeEventListener('focus', connect, false)\n        window.removeEventListener('online', connect, false)\n        window.removeEventListener('resume', connect, false)\n        window.removeEventListener('freeze', disconnect, false)\n      })\n    }\n  }\n\n  connect() {\n    this.attempts += 1\n    this.reconnecting = true\n    return this.connection.connect()\n  }\n\n  disconnect(reason) {\n    if (reason !== 'timeout' && reason !== 'error' && reason !== 'freeze') {\n      this.reconnecting = false\n    }\n    return this.connection.disconnect(reason)\n  }\n\n  destroy() {\n    for (let i of this.unbind) i()\n    this.disconnect('destroy')\n  }\n\n  reconnect() {\n    if (this.attempts > this.options.attempts - 1) {\n      this.reconnecting = false\n      this.attempts = 0\n      return\n    }\n\n    let delay = this.nextDelay()\n    this.timer = setTimeout(() => {\n      if (this.reconnecting && !this.connecting && !this.connected) {\n        this.connect()\n      }\n    }, delay)\n  }\n\n  send(...args) {\n    return this.connection.send(...args)\n  }\n\n  on(...args) {\n    return this.connection.on(...args)\n  }\n\n  nextDelay() {\n    let base = this.options.minDelay * 2 ** this.attempts\n    let rand = Math.random()\n    let deviation = Math.floor(rand * 0.5 * base)\n    if (Math.floor(rand * 10) === 1) deviation = -deviation\n    return Math.min(base + deviation, this.options.maxDelay) || 0\n  }\n\n  get connected() {\n    return this.connection.connected\n  }\n\n  get emitter() {\n    return this.connection.emitter\n  }\n}\n","export function parseId(nodeId) {\n  if (nodeId.includes(' ')) nodeId = nodeId.split(' ')[1]\n  let parts = nodeId.split(':')\n  if (parts.length === 1) {\n    return { nodeId, userId: undefined, clientId: nodeId }\n  } else {\n    let userId = parts[0]\n    return { nodeId, userId, clientId: parts[0] + ':' + parts[1] }\n  }\n}\n","export function status(client, callback, options = {}) {\n  let observable = client.on ? client : client.node\n  let disconnected = observable.state === 'disconnected'\n  let wait = false\n  let old = false\n\n  if (typeof options.duration === 'undefined') options.duration = 3000\n\n  let timeout\n  let unbind = []\n  let processing = {}\n\n  function setSynchronized() {\n    if (Object.keys(processing).length === 0) {\n      if (wait) {\n        wait = false\n        callback('synchronizedAfterWait')\n        timeout = setTimeout(() => {\n          callback('synchronized')\n        }, options.duration)\n      } else {\n        callback('synchronized')\n      }\n    }\n  }\n\n  function changeState() {\n    clearTimeout(timeout)\n\n    if (old) return\n    if (observable.state === 'disconnected') {\n      disconnected = true\n      callback(wait ? 'wait' : 'disconnected')\n    } else if (observable.state === 'synchronized') {\n      disconnected = false\n      setSynchronized()\n    } else if (observable.state === 'connecting') {\n      timeout = setTimeout(() => {\n        callback('connecting' + (wait ? 'AfterWait' : ''))\n      }, 100)\n    } else {\n      callback(client.state + (wait ? 'AfterWait' : ''))\n    }\n  }\n\n  unbind.push(observable.on('state', changeState))\n\n  unbind.push(\n    client.node.on('error', error => {\n      if (\n        error.type === 'wrong-protocol' ||\n        error.type === 'wrong-subprotocol'\n      ) {\n        old = true\n        callback('protocolError')\n      } else if (error.type !== 'timeout') {\n        callback('syncError', { error })\n      }\n    })\n  )\n\n  unbind.push(\n    client.node.on('clientError', error => {\n      callback('syncError', { error })\n    })\n  )\n\n  let log = client.on ? client : client.log\n  unbind.push(\n    log.on('add', (action, meta) => {\n      if (action.type === 'logux/subscribe') {\n        return\n      } else if (action.type === 'logux/unsubscribe') {\n        return\n      }\n\n      if (action.type === 'logux/processed') {\n        delete processing[action.id]\n        setSynchronized()\n      } else if (action.type === 'logux/undo') {\n        delete processing[action.id]\n      } else if (meta.sync) {\n        processing[meta.id] = true\n      }\n\n      if (action.type === 'logux/undo' && action.reason) {\n        if (action.reason === 'denied') {\n          callback('denied', { action, meta })\n        } else {\n          callback('error', { action, meta })\n        }\n      } else if (disconnected && meta.sync && meta.added) {\n        if (!wait) callback('wait')\n        wait = true\n      }\n    })\n  )\n\n  changeState()\n\n  return () => {\n    for (let i of unbind) i()\n  }\n}\n","import { status } from '../status/index.js'\n\nfunction injectStyles(element, styles) {\n  for (let i in styles) {\n    element.style[i] = styles[i]\n  }\n}\n\nfunction setPosition(element, position) {\n  let style = element.style\n  if (position === 'middle-center' || position === 'center-middle') {\n    style.top = '50%'\n    style.left = '50%'\n    style.transform = 'translate(-50%, -50%)'\n  } else {\n    position.split('-').forEach(pos => {\n      if (pos === 'middle') {\n        style.top = '50%'\n        style.transform = 'translateY(-50%)'\n      } else if (pos === 'center') {\n        style.left = '50%'\n        style.transform = 'translateX(-50%)'\n      } else {\n        style[pos] = '0'\n      }\n    })\n  }\n}\n\nconst RESET = {\n  boxSizing: 'content-box',\n  visibility: 'visible',\n  textIndent: '0',\n  textTransform: 'none',\n  wordSpacing: 'normal',\n  letterSpacing: 'normal',\n  fontStyle: 'normal',\n  fontVariant: 'normal',\n  fontWeight: 'normal',\n  lineHeight: 'auto'\n}\n\nexport function badge(client, opts) {\n  let messages = opts.messages\n  let position = opts.position || 'bottom-right'\n  let styles = opts.styles\n\n  let widget = document.createElement('div')\n  let text = document.createElement('span')\n\n  widget.setAttribute('role', 'alert')\n\n  injectStyles(widget, RESET)\n  injectStyles(widget, styles.base)\n  injectStyles(text, styles.text)\n  setPosition(widget, position)\n\n  let show = (style, msg) => {\n    text.innerHTML = msg\n    injectStyles(widget, style)\n    widget.style.display = 'block'\n  }\n\n  let hide = () => {\n    widget.style.display = 'none'\n  }\n\n  let unbind = status(\n    client,\n    state => {\n      if (state === 'sendingAfterWait' || state === 'connectingAfterWait') {\n        show(styles.sending, messages.sending)\n      } else if (state === 'synchronizedAfterWait') {\n        show(styles.synchronized, messages.synchronized)\n      } else if (state === 'synchronized') {\n        hide(widget)\n      } else if (state === 'disconnected') {\n        show(styles.disconnected, messages.disconnected)\n      } else if (state === 'wait') {\n        show(styles.wait, messages.wait)\n      } else if (state === 'protocolError') {\n        show(styles.protocolError, messages.protocolError)\n      } else if (state === 'syncError') {\n        show(styles.error, messages.syncError)\n      } else if (state === 'error') {\n        show(styles.error, messages.error)\n      } else if (state === 'denied') {\n        show(styles.error, messages.denied)\n      }\n    },\n    opts\n  )\n\n  widget.appendChild(text)\n  document.body.appendChild(widget)\n\n  return () => {\n    unbind()\n    document.body.removeChild(widget)\n  }\n}\n\nexport let badgeRu = {\n  synchronized: '  ',\n  disconnected: ' ',\n  wait: ' <br>   ',\n  sending: '  ',\n  syncError: '  <br>   ',\n  error: '  <br>  ',\n  denied: ' <br>  ',\n  protocolError: '  <br> '\n}\n\nexport let badgeEn = {\n  synchronized: 'Your data has been saved',\n  disconnected: 'No Internet connection',\n  wait: 'No Internet connection<br>Your data has not been saved',\n  sending: 'Data saving',\n  syncError: 'Server error<br>Your data has not been saved',\n  error: 'Server error<br>You changes was reverted',\n  denied: 'You have no access<br>You changes was reverted',\n  protocolError: 'Saving is not working<br>Refresh the page'\n}\n","// This file replaces `index.js` in bundlers like webpack or Rollup,\n// according to `browser` config in `package.json`.\n\nimport { urlAlphabet } from './url-alphabet/index.js'\n\nif (process.env.NODE_ENV !== 'production') {\n  // All bundlers will remove this block in the production bundle.\n  if (\n    typeof navigator !== 'undefined' &&\n    navigator.product === 'ReactNative' &&\n    typeof crypto === 'undefined'\n  ) {\n    throw new Error(\n      'React Native does not have a built-in secure random generator. ' +\n        'If you dont need unpredictable IDs use `nanoid/non-secure`. ' +\n        'For secure IDs, import `react-native-get-random-values` ' +\n        'before Nano ID.'\n    )\n  }\n  if (typeof msCrypto !== 'undefined' && typeof crypto === 'undefined') {\n    throw new Error(\n      'Import file with `if (!window.crypto) window.crypto = window.msCrypto`' +\n        ' before importing Nano ID to fix IE 11 support'\n    )\n  }\n  if (typeof crypto === 'undefined') {\n    throw new Error(\n      'Your browser does not have secure random generator. ' +\n        'If you dont need unpredictable IDs, you can use nanoid/non-secure.'\n    )\n  }\n}\n\nlet random = bytes => crypto.getRandomValues(new Uint8Array(bytes))\n\nlet customRandom = (alphabet, size, getRandom) => {\n  // First, a bitmask is necessary to generate the ID. The bitmask makes bytes\n  // values closer to the alphabet size. The bitmask calculates the closest\n  // `2^31 - 1` number, which exceeds the alphabet size.\n  // For example, the bitmask for the alphabet size 30 is 31 (00011111).\n  // `Math.clz32` is not used, because it is not available in browsers.\n  let mask = (2 << (Math.log(alphabet.length - 1) / Math.LN2)) - 1\n  // Though, the bitmask solution is not perfect since the bytes exceeding\n  // the alphabet size are refused. Therefore, to reliably generate the ID,\n  // the random bytes redundancy has to be satisfied.\n\n  // Note: every hardware random generator call is performance expensive,\n  // because the system call for entropy collection takes a lot of time.\n  // So, to avoid additional system calls, extra bytes are requested in advance.\n\n  // Next, a step determines how many random bytes to generate.\n  // The number of random bytes gets decided upon the ID size, mask,\n  // alphabet size, and magic number 1.6 (using 1.6 peaks at performance\n  // according to benchmarks).\n\n  // `-~f => Math.ceil(f)` if f is a float\n  // `-~i => i + 1` if i is an integer\n  let step = -~((1.6 * mask * size) / alphabet.length)\n\n  return () => {\n    let id = ''\n    while (true) {\n      let bytes = getRandom(step)\n      // A compact alternative for `for (var i = 0; i < step; i++)`.\n      let j = step\n      while (j--) {\n        // Adding `|| ''` refuses a random byte that exceeds the alphabet size.\n        id += alphabet[bytes[j] & mask] || ''\n        if (id.length === size) return id\n      }\n    }\n  }\n}\n\nlet customAlphabet = (alphabet, size) => customRandom(alphabet, size, random)\n\nlet nanoid = (size = 21) => {\n  let id = ''\n  let bytes = crypto.getRandomValues(new Uint8Array(size))\n\n  // A compact alternative for `for (var i = 0; i < step; i++)`.\n  while (size--) {\n    // It is incorrect to use bytes exceeding the alphabet size.\n    // The following mask reduces the random byte in the 0-255 value\n    // range to the 0-63 value range. Therefore, adding hacks, such\n    // as empty string fallback or magic numbers, is unneccessary because\n    // the bitmask trims bytes down to the alphabet size.\n    let byte = bytes[size] & 63\n    if (byte < 36) {\n      // `0-9a-z`\n      id += byte.toString(36)\n    } else if (byte < 62) {\n      // `A-Z`\n      id += (byte - 26).toString(36).toUpperCase()\n    } else if (byte < 63) {\n      id += '_'\n    } else {\n      id += '-'\n    }\n  }\n  return id\n}\n\nexport { nanoid, customAlphabet, customRandom, urlAlphabet, random }\n","export class LoguxUndoError extends Error {\n  constructor(action) {\n    let type = action.action ? action.action.type : 'action'\n    super(`Server undid ${type} because of ${action.reason}`)\n    this.name = 'LoguxUndoError'\n    this.action = action\n  }\n}\n","import { createNanoEvents } from 'nanoevents'\nimport {\n  isFirstOlder,\n  WsConnection,\n  MemoryStore,\n  ClientNode,\n  Reconnect,\n  parseId,\n  Log\n} from '@logux/core'\nimport { nanoid } from 'nanoid'\n\nimport { LoguxUndoError } from '../logux-undo-error/index.js'\nimport { track } from '../track/index.js'\n\nlet ALLOWED_META = ['id', 'time', 'subprotocol']\n\nfunction tabPing(c) {\n  localStorage.setItem(c.options.prefix + ':tab:' + c.tabId, Date.now())\n}\n\nfunction cleanTabActions(client, id) {\n  client.log.removeReason('tab' + id).then(() => {\n    if (client.isLocalStorage) {\n      localStorage.removeItem(client.options.prefix + ':tab:' + id)\n    }\n  })\n}\n\nexport class Client {\n  constructor(opts = {}) {\n    this.options = opts\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof this.options.server === 'undefined') {\n        throw new Error('Missed server option in Logux client')\n      }\n      if (typeof this.options.subprotocol === 'undefined') {\n        throw new Error('Missed subprotocol option in Logux client')\n      }\n      if (typeof this.options.userId === 'undefined') {\n        throw new Error(\n          'Missed userId option in Logux client. ' +\n            'Pass false if you have no users.'\n        )\n      }\n      if (this.options.userId === false) {\n        throw new Error('Replace userId: false to userId: \"false\"')\n      }\n      if (typeof this.options.userId !== 'string') {\n        throw new Error('userId must be a string')\n      }\n      if (this.options.userId.includes(':')) {\n        throw new Error('userId cant contain colon character')\n      }\n    }\n\n    if (typeof this.options.prefix === 'undefined') {\n      this.options.prefix = 'logux'\n    }\n\n    this.isLocalStorage = false\n    if (typeof localStorage !== 'undefined') {\n      let random = nanoid()\n      try {\n        localStorage.setItem(random, '1')\n        localStorage.removeItem(random)\n        this.isLocalStorage = true\n      } catch {}\n    }\n\n    if (!this.options.time) {\n      this.clientId = this.options.userId + ':' + this.getClientId()\n      this.tabId = nanoid(8)\n    } else {\n      this.tabId = this.options.time.lastId + 1 + ''\n      this.clientId = this.options.userId + ':' + this.tabId\n    }\n\n    this.nodeId = this.clientId + ':' + this.tabId\n    let store = this.options.store || new MemoryStore()\n\n    let log\n    if (this.options.time) {\n      log = this.options.time.nextLog({ store, nodeId: this.nodeId })\n    } else {\n      log = new Log({ store, nodeId: this.nodeId })\n    }\n    this.log = log\n\n    log.on('preadd', (action, meta) => {\n      if (parseId(meta.id).nodeId === this.nodeId && !meta.subprotocol) {\n        meta.subprotocol = this.options.subprotocol\n      }\n      if (meta.sync && !meta.resubscribe) meta.reasons.push('syncing')\n    })\n\n    this.last = {}\n    this.subscriptions = {}\n    let subscribing = {}\n    let unsubscribing = {}\n\n    this.emitter = createNanoEvents()\n    this.on('add', (action, meta) => {\n      let type = action.type\n      let json, last\n      if (type === 'logux/processed' || type === 'logux/undo') {\n        this.log.removeReason('syncing', { id: action.id })\n      }\n      if (type === 'logux/subscribe' && !meta.resubscribe) {\n        subscribing[meta.id] = action\n      } else if (type === 'logux/unsubscribe') {\n        unsubscribing[meta.id] = action\n      } else if (type === 'logux/processed') {\n        if (unsubscribing[action.id]) {\n          let unsubscription = unsubscribing[action.id]\n          json = JSON.stringify({ ...unsubscription, type: 'logux/subscribe' })\n          let subscribers = this.subscriptions[json]\n          if (subscribers) {\n            if (subscribers === 1) {\n              delete this.subscriptions[json]\n            } else {\n              this.subscriptions[json] = subscribers - 1\n            }\n          }\n        }\n        if (subscribing[action.id]) {\n          let subscription = subscribing[action.id]\n          delete subscribing[action.id]\n          json = JSON.stringify(subscription)\n          if (this.subscriptions[json]) {\n            this.subscriptions[json] += 1\n          } else {\n            this.subscriptions[json] = 1\n          }\n          last = this.last[subscription.channel]\n          if (!last || isFirstOlder(last, meta)) {\n            this.last[subscription.channel] = { id: meta.id, time: meta.time }\n          }\n        }\n        if (type === 'logux/processed' && this.processing[action.id]) {\n          this.processing[action.id][1](meta)\n          delete this.processing[action.id]\n        }\n      } else if (type === 'logux/undo') {\n        if (this.processing[action.id]) {\n          this.processing[action.id][2](new LoguxUndoError(action))\n          delete this.processing[action.id]\n        }\n        delete subscribing[action.id]\n        delete unsubscribing[action.id]\n      } else if (meta.channels) {\n        if (!meta.id.includes(' ' + this.clientId + ':')) {\n          meta.channels.forEach(channel => {\n            last = this.last[channel]\n            if (!last || isFirstOlder(last, meta)) {\n              this.last[channel] = { id: meta.id, time: meta.time }\n            }\n          })\n        }\n      }\n      if (process.env.NODE_ENV !== 'production') {\n        if (type === 'logux/subscribe' || type === 'logux/unsubscribe') {\n          if (!meta.sync) {\n            console.error(type + ' action without meta.sync')\n          }\n        }\n      }\n    })\n\n    this.tabPing = 60000\n    this.tabTimeout = 10 * this.tabPing\n    let reason = 'tab' + this.tabId\n    if (this.isLocalStorage) {\n      let unbind = log.on('add', (action, meta) => {\n        if (meta.reasons.includes(reason)) {\n          tabPing(this)\n          this.pinging = setInterval(() => {\n            tabPing(this)\n          }, this.tabPing)\n          unbind()\n        }\n      })\n    }\n\n    let connection\n    if (typeof this.options.server === 'string') {\n      let ws = new WsConnection(this.options.server)\n      connection = new Reconnect(ws, {\n        minDelay: this.options.minDelay,\n        maxDelay: this.options.maxDelay,\n        attempts: this.options.attempts\n      })\n    } else {\n      connection = this.options.server\n    }\n\n    let outFilter = async (action, meta) => {\n      return !!meta.sync && parseId(meta.id).userId === this.options.userId\n    }\n\n    let outMap = async (action, meta) => {\n      let filtered = {}\n      for (let i in meta) {\n        if (i === 'subprotocol') {\n          if (meta.subprotocol !== this.options.subprotocol) {\n            filtered.subprotocol = meta.subprotocol\n          }\n        } else if (ALLOWED_META.includes(i)) {\n          filtered[i] = meta[i]\n        }\n      }\n      return [action, filtered]\n    }\n\n    if (!this.options.time) {\n      if (typeof this.options.timeout === 'undefined') {\n        this.options.timeout = 20000\n      }\n      if (typeof this.options.ping === 'undefined') {\n        this.options.ping = 5000\n      }\n    }\n\n    this.node = new ClientNode(this.nodeId, this.log, connection, {\n      subprotocol: this.options.subprotocol,\n      outFilter,\n      timeout: this.options.timeout,\n      fixTime: !this.options.time,\n      outMap,\n      token: this.options.token,\n      ping: this.options.ping\n    })\n\n    if (/^ws:\\/\\//.test(this.options.server) && !opts.allowDangerousProtocol) {\n      let unbindEnvTest = this.node.on('state', () => {\n        if (this.node.state === 'synchronized') {\n          unbindEnvTest()\n          if (this.node.remoteHeaders.env !== 'development') {\n            console.error(\n              'Without SSL, old proxies block WebSockets. ' +\n                'Use WSS for Logux or set allowDangerousProtocol option.'\n            )\n            this.destroy()\n          }\n        }\n      })\n    }\n\n    this.node.on('debug', (type, stack) => {\n      if (type === 'error') {\n        console.error('Error on Logux server:\\n', stack)\n      }\n    })\n\n    let disconnected = true\n    this.node.on('state', () => {\n      let state = this.node.state\n      if (state === 'synchronized' || state === 'sending') {\n        if (disconnected) {\n          disconnected = false\n          for (let i in this.subscriptions) {\n            let action = JSON.parse(i)\n            let since = this.last[action.channel]\n            if (since) action.since = since\n            this.log.add(action, { sync: true, resubscribe: true })\n          }\n        }\n      } else if (this.node.state === 'disconnected') {\n        disconnected = true\n      }\n    })\n\n    this.onUnload = this.onUnload.bind(this)\n    if (typeof window !== 'undefined' && window.addEventListener) {\n      window.addEventListener('unload', this.onUnload)\n    }\n\n    this.processing = {}\n  }\n\n  get state() {\n    return this.node.state\n  }\n\n  get connected() {\n    return this.state !== 'disconnected' && this.state !== 'connecting'\n  }\n\n  start() {\n    this.cleanPrevActions()\n    this.node.connection.connect()\n  }\n\n  sync(action, meta = {}) {\n    meta.sync = true\n    if (typeof meta.id === 'undefined') {\n      meta.id = this.log.generateId()\n    }\n\n    this.log.add(action, meta)\n    return track(this, meta.id)\n  }\n\n  type(type, listener, opts) {\n    return this.log.type(type, listener, opts)\n  }\n\n  on(event, listener) {\n    if (event === 'state') {\n      return this.node.emitter.on(event, listener)\n    } else if (event === 'user') {\n      return this.emitter.on(event, listener)\n    } else {\n      return this.log.emitter.on(event, listener)\n    }\n  }\n\n  changeUser(userId, token) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof userId !== 'string') {\n        throw new Error('userId must be a string')\n      }\n      if (userId.includes(':')) {\n        throw new Error('userId cant contain colon character')\n      }\n    }\n\n    let wasConnected = this.node.connected\n    if (wasConnected) this.node.connection.disconnect('destroy')\n\n    this.options.userId = userId\n    this.options.token = token\n    this.clientId = userId + ':' + this.getClientId()\n    this.nodeId = this.clientId + ':' + this.tabId\n\n    this.log.nodeId = this.nodeId\n    this.node.localNodeId = this.nodeId\n    this.node.options.token = token\n\n    this.emitter.emit('user', userId)\n    if (wasConnected) this.node.connection.connect()\n  }\n\n  waitFor(state) {\n    if (this.state === state) {\n      return Promise.resolve()\n    }\n    return new Promise(resolve => {\n      let unbind = this.on('state', () => {\n        if (this.state === state) {\n          unbind()\n          resolve()\n        }\n      })\n    })\n  }\n\n  destroy() {\n    this.onUnload()\n    this.node.destroy()\n    clearInterval(this.pinging)\n    if (typeof window !== 'undefined' && window.removeEventListener) {\n      window.removeEventListener('unload', this.onUnload)\n    }\n  }\n\n  clean() {\n    this.destroy()\n    return this.log.store.clean ? this.log.store.clean() : Promise.resolve()\n  }\n\n  cleanPrevActions() {\n    if (!this.isLocalStorage) return\n\n    for (let i in localStorage) {\n      let prefix = this.options.prefix + ':tab:'\n      if (i.slice(0, prefix.length) === prefix) {\n        let time = parseInt(localStorage.getItem(i))\n        if (Date.now() - time > this.tabTimeout) {\n          cleanTabActions(this, i.slice(prefix.length))\n        }\n      }\n    }\n  }\n\n  onUnload() {\n    if (this.pinging) cleanTabActions(this, this.tabId)\n  }\n\n  getClientId() {\n    return nanoid(8)\n  }\n}\n","import { LoguxError, actionEvents } from '@logux/core'\n\nimport { Client } from '../client/index.js'\n\nfunction storageKey(client, name) {\n  return client.options.prefix + ':' + client.options.userId + ':' + name\n}\n\nfunction sendToTabs(client, event, data) {\n  if (!client.isLocalStorage) return\n  let key = storageKey(client, event)\n  let json = JSON.stringify(data)\n  try {\n    localStorage.setItem(key, json)\n  } catch (e) {\n    console.error(e)\n    client.isLocalStorage = false\n    client.role = 'leader'\n    client.emitter.emit('role')\n    client.node.connection.connect()\n  }\n}\n\nfunction getLeader(client) {\n  let data = localStorage.getItem(storageKey(client, 'leader'))\n  let json = []\n  if (typeof data === 'string') json = JSON.parse(data)\n  return json\n}\n\nfunction leaderPing(client) {\n  sendToTabs(client, 'leader', [client.tabId, Date.now()])\n}\n\nfunction onDeadLeader(client) {\n  if (client.state !== 'disconnected') {\n    setState(client, 'disconnected')\n  }\n  startElection(client)\n}\n\nfunction watchForLeader(client) {\n  clearTimeout(client.watching)\n  client.watching = setTimeout(() => {\n    if (!isActiveLeader(client)) {\n      onDeadLeader(client)\n    } else {\n      watchForLeader(client)\n    }\n  }, client.roleTimeout)\n}\n\nfunction compareSubprotocols(left, right) {\n  let leftParts = left.split('.')\n  let rightParts = right.split('.')\n  for (let i = 0; i < 3; i++) {\n    let leftNumber = parseInt(leftParts[i] || 0)\n    let rightNumber = parseInt(rightParts[i] || 0)\n    if (leftNumber > rightNumber) {\n      return 1\n    } else if (leftNumber < rightNumber) {\n      return -1\n    }\n  }\n  return 0\n}\n\nfunction setRole(client, role) {\n  if (client.role !== role) {\n    let node = client.node\n    client.role = role\n\n    clearTimeout(client.watching)\n    if (role === 'leader') {\n      localStorage.removeItem(storageKey(client, 'state'))\n      client.leadership = setInterval(() => {\n        if (!client.unloading) leaderPing(client)\n      }, client.leaderPing)\n      node.connection.connect()\n    } else {\n      clearTimeout(client.elections)\n      clearInterval(client.leadership)\n\n      if (node.state !== 'disconnected') {\n        client.node.connection.disconnect()\n      }\n    }\n\n    if (role === 'follower') {\n      let state = 'disconnected'\n      let json = localStorage.getItem(storageKey(client, 'state'))\n      if (json && json !== null) state = JSON.parse(json)\n      if (state !== client.state) {\n        client.state = state\n        client.emitter.emit('state')\n      }\n    }\n\n    client.emitter.emit('role')\n  }\n}\n\nfunction isActiveLeader(client) {\n  let leader = getLeader(client)\n  return leader[1] && leader[1] >= Date.now() - client.leaderTimeout\n}\n\nfunction startElection(client) {\n  leaderPing(client)\n  setRole(client, 'candidate')\n  client.elections = setTimeout(() => {\n    let data = getLeader(client, 'leader')\n    if (data[0] === client.tabId) {\n      setRole(client, 'leader')\n    } else {\n      setRole(client, 'follower')\n      watchForLeader(client)\n    }\n  }, client.electionDelay)\n}\n\nfunction setState(client, state) {\n  client.state = state\n  client.emitter.emit('state')\n  sendToTabs(client, 'state', client.state)\n}\n\nfunction isMemory(store) {\n  return Array.isArray(store.entries) && Array.isArray(store.added)\n}\n\nexport class CrossTabClient extends Client {\n  constructor(opts = {}) {\n    super(opts)\n\n    this.role = 'candidate'\n\n    this.roleTimeout = 3000 + Math.floor(Math.random() * 1000)\n    this.leaderTimeout = 5000\n    this.leaderPing = 2000\n    this.electionDelay = 1000\n\n    this.leaderState = this.node.state\n\n    this.node.on('state', () => {\n      if (this.role === 'leader') {\n        setState(this, this.node.state)\n      }\n    })\n\n    this.log.on('add', (action, meta) => {\n      actionEvents(this.emitter, 'add', action, meta)\n      if (meta.tab !== this.tabId) {\n        sendToTabs(this, 'add', [this.tabId, action, meta])\n      }\n    })\n    this.log.on('clean', (action, meta) => {\n      actionEvents(this.emitter, 'clean', action, meta)\n    })\n\n    if (typeof window !== 'undefined' && window.addEventListener) {\n      window.addEventListener('storage', e => this.onStorage(e))\n      window.addEventListener('unload', e => this.onUnload(e))\n    }\n\n    if (this.isLocalStorage) {\n      let subprotocolKey = storageKey(this, 'subprotocol')\n      if (localStorage.getItem(subprotocolKey) !== this.options.subprotocol) {\n        sendToTabs(this, 'subprotocol', this.options.subprotocol)\n      }\n    }\n  }\n\n  get state() {\n    return this.leaderState\n  }\n\n  set state(value) {\n    this.leaderState = value\n  }\n\n  start() {\n    this.cleanPrevActions()\n\n    if (!this.isLocalStorage) {\n      this.role = 'leader'\n      this.emitter.emit('role')\n      this.node.connection.connect()\n      return\n    }\n\n    if (isActiveLeader(this)) {\n      setRole(this, 'follower')\n      watchForLeader(this)\n    } else {\n      startElection(this)\n    }\n  }\n\n  destroy() {\n    super.destroy()\n\n    clearTimeout(this.watching)\n    clearTimeout(this.elections)\n    clearInterval(this.leadership)\n    if (typeof window !== 'undefined' && window.removeEventListener) {\n      window.removeEventListener('storage', this.onStorage)\n    }\n  }\n\n  clean() {\n    if (this.isLocalStorage) {\n      localStorage.removeItem(storageKey(this, 'add'))\n      localStorage.removeItem(storageKey(this, 'state'))\n      localStorage.removeItem(storageKey(this, 'client'))\n      localStorage.removeItem(storageKey(this, 'leader'))\n    }\n    return super.clean()\n  }\n\n  changeUser(userId, token) {\n    sendToTabs(this, 'user', [this.tabId, userId])\n    super.changeUser(userId, token)\n  }\n\n  type(type, listener, opts = {}) {\n    if (opts.event === 'preadd') {\n      return this.log.type(type, listener, opts)\n    } else {\n      let event = opts.event || 'add'\n      let id = opts.id || ''\n      return this.emitter.on(`${event}-${type}-${id}`, listener)\n    }\n  }\n\n  on(event, listener) {\n    if (event === 'preadd') {\n      return this.log.emitter.on(event, listener)\n    } else {\n      return this.emitter.on(event, listener)\n    }\n  }\n\n  onStorage(e) {\n    if (e.newValue === null) return\n\n    let data\n    if (e.key === storageKey(this, 'add')) {\n      data = JSON.parse(e.newValue)\n      if (data[0] !== this.tabId) {\n        let action = data[1]\n        let meta = data[2]\n        if (!meta.tab || meta.tab === this.tabId) {\n          if (isMemory(this.log.store)) {\n            this.log.store.add(action, meta)\n          }\n          actionEvents(this.emitter, 'add', action, meta)\n          if (this.role === 'leader') {\n            this.node.onAdd(action, meta)\n          }\n        }\n      }\n    } else if (e.key === storageKey(this, 'leader')) {\n      data = JSON.parse(e.newValue)\n      if (data.length === 0) {\n        onDeadLeader(this)\n      } else if (data[0] !== this.tabId && this.role !== 'candidate') {\n        setRole(this, 'follower')\n        watchForLeader(this)\n      }\n    } else if (e.key === storageKey(this, 'state')) {\n      let state = JSON.parse(localStorage.getItem(e.key))\n      if (this.leaderState !== state) {\n        this.leaderState = state\n        this.emitter.emit('state')\n      }\n    } else if (e.key === storageKey(this, 'user')) {\n      data = JSON.parse(e.newValue)\n      if (data[0] !== this.tabId) {\n        this.emitter.emit('user', data[1])\n      }\n    } else if (e.key === storageKey(this, 'subprotocol')) {\n      let other = JSON.parse(e.newValue)\n      let compare = compareSubprotocols(this.options.subprotocol, other)\n      if (compare === 1) {\n        sendToTabs(this, 'subprotocol', this.options.subprotocol)\n      } else if (compare === -1) {\n        let err = new LoguxError(\n          'wrong-subprotocol',\n          { supported: other, used: this.options.subprotocol },\n          true\n        )\n        this.node.emitter.emit('error', err)\n      }\n    }\n  }\n\n  onUnload() {\n    if (this.role === 'leader') {\n      this.unloading = true\n      sendToTabs(this, 'leader', [])\n    }\n    super.onUnload()\n  }\n\n  getClientId() {\n    let key = storageKey(this, 'client')\n    if (!this.isLocalStorage) {\n      return super.getClientId()\n    } else if (localStorage.getItem(key)) {\n      return localStorage.getItem(key)\n    } else {\n      let clientId = super.getClientId()\n      localStorage.setItem(key, clientId)\n      return clientId\n    }\n  }\n}\n","function block(e) {\n  e.returnValue = 'unsynced'\n  return 'unsynced'\n}\n\nexport function confirm(client) {\n  let disconnected = client.state === 'disconnected'\n  let wait = false\n\n  let update = () => {\n    if (client.state === 'disconnected') {\n      disconnected = true\n    } else if (client.state === 'synchronized') {\n      disconnected = false\n      wait = false\n    }\n\n    if (typeof window !== 'undefined' && window.addEventListener) {\n      if (client.role !== 'follower' && wait && disconnected) {\n        window.addEventListener('beforeunload', block)\n      } else {\n        window.removeEventListener('beforeunload', block)\n      }\n    }\n  }\n\n  let unbind = []\n  unbind.push(client.on('role', update))\n  unbind.push(client.on('state', update))\n  update()\n\n  unbind.push(\n    client.on('add', (action, meta) => {\n      if (action.type === 'logux/subscribe') {\n        return\n      } else if (action.type === 'logux/unsubscribe') {\n        return\n      }\n      if (disconnected && meta.sync && meta.added) {\n        wait = true\n        update()\n      }\n    })\n  )\n\n  return () => {\n    for (let i of unbind) i()\n  }\n}\n","import { parseId } from '@logux/core'\n\nfunction bold(string) {\n  return '%c' + string + '%c'\n}\n\nfunction showLog(text, details) {\n  text = '%cLogux%c ' + text\n  let args = Array.from(text.match(/%c/g)).map((_, i) => {\n    if (i === 0) {\n      return 'color:#ffa200;font-weight:bold'\n    } else if (i % 2 === 0) {\n      return 'font-weight:bold'\n    } else {\n      return 'font-weight:normal'\n    }\n  })\n\n  if (details) {\n    console.groupCollapsed(text, ...args)\n    for (let name in details) {\n      if (typeof details[name] === 'string') {\n        console.log(name + ': %c' + details[name], 'font-weight:bold')\n      } else {\n        console.log(name, details[name])\n      }\n    }\n    console.groupEnd()\n  } else {\n    console.log(text, ...args)\n  }\n}\n\nexport function log(client, messages = {}) {\n  let node = client.node\n\n  let sent = {}\n  let unbind = []\n  let prevConnected = false\n\n  if (messages.state !== false) {\n    unbind.push(\n      client.on('state', () => {\n        let details\n        if (client.state === 'connecting' && node.connection.url) {\n          details = {\n            'Node ID': node.localNodeId,\n            'Server': node.connection.url\n          }\n        } else if (client.connected && !prevConnected && node.remoteNodeId) {\n          prevConnected = true\n          details = {\n            'Server ID': node.remoteNodeId\n          }\n        } else if (!client.connected) {\n          prevConnected = false\n        }\n        showLog('state is ' + bold(client.state), details)\n      })\n    )\n  }\n\n  if (messages.role !== false) {\n    unbind.push(\n      client.on('role', () => {\n        showLog('tab role is ' + bold(client.role))\n      })\n    )\n  }\n\n  let cleaned = {}\n  let ignore = (messages.ignoreActions || []).reduce((all, i) => {\n    all[i] = true\n    return all\n  }, {})\n\n  if (messages.add !== false) {\n    unbind.push(\n      client.on('add', (action, meta) => {\n        if (meta.tab && meta.tab !== client.tabId) return\n        if (ignore[action.type]) return\n        if (meta.sync) sent[meta.id] = action\n        let message\n        if (action.type === 'logux/subscribe') {\n          message = 'subscribing to ' + bold(action.channel) + ' channel'\n          if (Object.keys(action).length === 2) {\n            showLog(message)\n          } else {\n            showLog(message, { Action: action })\n          }\n        } else if (action.type === 'logux/subscribed') {\n          showLog(\n            'subscribed to ' + bold(action.channel) + ' channel by server'\n          )\n        } else if (action.type === 'logux/unsubscribe') {\n          message = 'unsubscribed from channel ' + bold(action.channel)\n          if (Object.keys(action).length === 2) {\n            showLog(message)\n          } else {\n            showLog(message, { Action: action })\n          }\n        } else if (action.type === 'logux/processed') {\n          if (sent[action.id]) {\n            let processed = sent[action.id]\n            let details = {\n              'Processed Action': processed\n            }\n            if (processed.type === 'logux/subscribe') {\n              showLog(\n                'subscribed to ' + bold(processed.channel) + ' channel',\n                details\n              )\n            } else {\n              showLog(\n                'action ' + bold(processed.type) + ' was processed',\n                details\n              )\n            }\n            delete sent[action.id]\n          } else {\n            showLog('action ' + bold(action.id) + ' was processed')\n          }\n        } else if (action.type === 'logux/undo') {\n          if (action.action.type === 'logux/subscribe') {\n            message = 'subscription to ' + bold(action.action.channel)\n          } else {\n            message = 'action ' + bold(action.action.type)\n          }\n          message += ' was undone because of ' + bold(action.reason)\n          let details = {\n            'Reverted Action': action.action\n          }\n          if (Object.keys(action).length > 4) {\n            details['Undo Action'] = action\n          }\n          if (sent[action.id]) {\n            delete sent[action.id]\n          }\n          showLog(message, details)\n        } else {\n          let details = { Action: action, Meta: meta }\n          message = 'added '\n          if (meta.reasons.length === 0) {\n            cleaned[meta.id] = true\n            message += 'and cleaned '\n          }\n          message += bold(action.type) + ' action'\n          let { nodeId } = parseId(meta.id)\n          if (nodeId !== node.localNodeId) {\n            details.From = nodeId\n          }\n          showLog(message, details)\n        }\n      })\n    )\n  }\n\n  if (messages.user !== false) {\n    unbind.push(\n      client.on('user', userId => {\n        let message = 'user ID was changed to ' + bold(userId)\n        showLog(message, { 'Node ID': client.nodeId })\n      })\n    )\n  }\n\n  if (messages.clean !== false) {\n    unbind.push(\n      client.on('clean', (action, meta) => {\n        if (cleaned[meta.id]) {\n          delete cleaned[meta.id]\n          return\n        }\n        if (meta.tab && meta.tab !== client.id) return\n        if (ignore[action.type]) return\n        if (action.type.startsWith('logux/')) return\n        let message = 'cleaned ' + bold(action.type) + ' action'\n        showLog(message, { Action: action, Meta: meta })\n      })\n    )\n  }\n\n  return () => {\n    for (let i of unbind) i()\n  }\n}\n","\"use strict\";\n\n/* globals document:readonly */\nvar bundleURL = null;\n\nfunction getBundleURLCached() {\n  if (!bundleURL) {\n    bundleURL = getBundleURL();\n  }\n\n  return bundleURL;\n}\n\nfunction getBundleURL() {\n  try {\n    throw new Error();\n  } catch (err) {\n    var matches = ('' + err.stack).match(/(https?|file|ftp):\\/\\/[^)\\n]+/g);\n\n    if (matches) {\n      return getBaseURL(matches[0]);\n    }\n  }\n\n  return '/';\n}\n\nfunction getBaseURL(url) {\n  return ('' + url).replace(/^((?:https?|file|ftp):\\/\\/.+)\\/[^/]+$/, '$1') + '/';\n} // TODO: Replace uses with `new URL(url).origin` when ie11 is no longer supported.\n\n\nfunction getOrigin(url) {\n  let matches = ('' + url).match(/(https?|file|ftp):\\/\\/[^/]+/);\n\n  if (!matches) {\n    throw new Error('Origin not found');\n  }\n\n  return matches[0];\n}\n\nexports.getBundleURL = getBundleURLCached;\nexports.getBaseURL = getBaseURL;\nexports.getOrigin = getOrigin;","\"use strict\";\n\nvar resolve = require('./bundle-manifest').resolve;\n\nmodule.exports = function (fromId, toId) {\n  return relative(dirname(resolve(fromId)), resolve(toId));\n};\n\nfunction dirname(_filePath) {\n  if (_filePath === '') {\n    return '.';\n  }\n\n  var filePath = _filePath[_filePath.length - 1] === '/' ? _filePath.slice(0, _filePath.length - 1) : _filePath;\n  var slashIndex = filePath.lastIndexOf('/');\n  return slashIndex === -1 ? '.' : filePath.slice(0, slashIndex);\n}\n\nfunction relative(from, to) {\n  if (from === to) {\n    return '';\n  }\n\n  var fromParts = from.split('/');\n\n  if (fromParts[0] === '.') {\n    fromParts.shift();\n  }\n\n  var toParts = to.split('/');\n\n  if (toParts[0] === '.') {\n    toParts.shift();\n  } // Find where path segments diverge.\n\n\n  var i;\n  var divergeIndex;\n\n  for (i = 0; (i < toParts.length || i < fromParts.length) && divergeIndex == null; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      divergeIndex = i;\n    }\n  } // If there are segments from \"from\" beyond the point of divergence,\n  // return back up the path to that point using \"..\".\n\n\n  var parts = [];\n\n  for (i = 0; i < fromParts.length - divergeIndex; i++) {\n    parts.push('..');\n  } // If there are segments from \"to\" beyond the point of divergence,\n  // continue using the remaining segments.\n\n\n  if (toParts.length > divergeIndex) {\n    parts.push.apply(parts, toParts.slice(divergeIndex));\n  }\n\n  return parts.join('/');\n}\n\nmodule.exports._dirname = dirname;\nmodule.exports._relative = relative;","import refresh from './refresh.svg'\nimport success from './success.svg'\nimport offline from './offline.svg'\nimport error from './error.svg'\n\nexport let badgeStyles = {\n  base: {\n    position: 'fixed',\n    width: '15.4em',\n    height: '4em',\n    lineHeight: '1.4',\n    margin: '1.5em',\n    paddingLeft: '4.2em',\n    opacity: '0.8',\n    borderRadius: '0.4em',\n    color: '#fff',\n    fontFamily: 'Helvetica Neue, sans-serif',\n    zIndex: '999',\n    backgroundPosition: '1.2em center',\n    backgroundRepeat: 'no-repeat',\n    backgroundSize: '1.8em'\n  },\n  text: {\n    display: 'table-cell',\n    verticalAlign: 'middle',\n    height: '4em'\n  },\n  synchronized: {\n    backgroundColor: '#000',\n    backgroundImage: 'url(' + success + ')'\n  },\n  disconnected: {\n    backgroundColor: '#000',\n    backgroundImage: 'url(' + offline + ')'\n  },\n  wait: {\n    backgroundColor: '#000',\n    backgroundImage: 'url(' + offline + ')'\n  },\n  sending: {\n    backgroundColor: '#000',\n    backgroundImage: 'url(' + refresh + ')'\n  },\n  error: {\n    backgroundColor: '#F42A2A',\n    backgroundImage: 'url(' + error + ')'\n  },\n  protocolError: {\n    backgroundColor: '#000',\n    backgroundImage: 'url(' + refresh + ')'\n  }\n}\n","import { MemoryStore, ClientNode, LocalPair, BaseNode, Log } from '@logux/core'\n\nimport {\n  CrossTabClient,\n  attention,\n  badgeEn,\n  confirm,\n  favicon,\n  status,\n  badge,\n  log\n} from '../../index.js'\nimport { badgeStyles } from '../../badge/styles/index.js'\nimport faviconOffline from './offline.png'\nimport faviconNormal from './normal.png'\nimport faviconError from './error.png'\n\nlet pair = new LocalPair(500)\n\nlet serverLog = new Log({\n  store: new MemoryStore(),\n  nodeId: 'server:uuid'\n})\nnew BaseNode('server:uuid', serverLog, pair.right)\n\nserverLog.on('add', (action, meta) => {\n  if (action.type !== 'logux/processed') {\n    setTimeout(() => {\n      serverLog.add({ type: 'logux/processed', id: meta.id })\n    }, 500)\n  }\n})\n\nlet client = new CrossTabClient({\n  subprotocol: location.hash.slice(1) || '1.0.0',\n  userId: '10',\n  server: 'wss://example.com/'\n})\n\nlet node = new ClientNode(client.node.localNodeId, client.log, pair.left)\nnode.connection.url = 'wss://example.com/'\nnode.emitter = client.node.emitter\nclient.node = node\n\nattention(client)\nconfirm(client)\nfavicon(client, {\n  normal: faviconNormal,\n  offline: faviconOffline,\n  error: faviconError\n})\nbadge(client, {\n  messages: badgeEn,\n  styles: badgeStyles\n})\nlog(client)\nstatus(client, s => {\n  document.all.status.innerText = s\n})\n\nlet count = 0\nfunction emoji(state) {\n  if (state === 'disconnected') {\n    return ''\n  } else if (state === 'connecting') {\n    return ''\n  } else {\n    return ''\n  }\n}\nfunction role(value) {\n  return value.slice(0, 1).toUpperCase()\n}\nfunction updateTitle() {\n  document.title = emoji(client.state) + ' ' + role(client.role) + ' ' + count\n}\n\nclient.on('state', () => {\n  document.all.connection.checked = client.connected\n  updateTitle()\n})\nclient.on('role', () => {\n  updateTitle()\n  document.all.connection.disabled = client.role !== 'leader'\n})\nclient.on('add', action => {\n  if (action.type === 'TICK') count++\n  updateTitle()\n})\nclient.on('clean', action => {\n  if (action.type === 'TICK') count--\n  updateTitle()\n})\n\nclient.log\n  .each(action => {\n    if (action.type === 'TICK') count++\n  })\n  .then(() => {\n    updateTitle()\n  })\n\nclient.on('role', () => {\n  let isLeader = client.role === 'leader'\n  document.all.connection.disabled = !isLeader\n  document.all.disabled.style.display = isLeader ? 'none' : 'inline'\n})\n\nclient.start()\n\ndocument.all.connection.onchange = e => {\n  if (e.target.checked) {\n    client.node.connection.connect()\n  } else {\n    client.node.connection.disconnect()\n  }\n}\n\ndocument.all.add.onclick = () => {\n  client.log.add({ type: 'TICK' }, { reasons: ['tick'], sync: true })\n}\n\ndocument.all.clean.onclick = () => {\n  client.log.removeReason('tick')\n}\n\ndocument.all.error.onclick = () => {\n  setTimeout(() => {\n    client.log.add({ type: 'logux/undo', reason: 'error' })\n  }, 3000)\n}\n\ndocument.all.denied.onclick = () => {\n  setTimeout(() => {\n    client.log.add({ type: 'logux/undo', reason: 'denied' })\n  }, 3000)\n}\n\ndocument.all.serverError.onclick = () => {\n  setTimeout(() => {\n    pair.right.send(['error', 'wrong-format'])\n  }, 3000)\n}\n\ndocument.all.subprotocolError.onclick = () => {\n  client.node.syncError('wrong-subprotocol', {\n    supported: '2.x',\n    used: '1.0.0'\n  })\n}\n\nif (client.options.subprotocol === '1.0.1') {\n  document.all.subprotocolClient.disabled = true\n} else {\n  document.all.subprotocolClient.onclick = () => {\n    window.open(location.toString() + '#1.0.1', '_blank')\n  }\n}\n","export function track(client, id) {\n  if (client.processing[id]) return client.processing[id][0]\n\n  let resolveCallback, rejectCallback\n  let promise = new Promise((resolve, reject) => {\n    resolveCallback = resolve\n    rejectCallback = reject\n  })\n  client.processing[id] = [promise, resolveCallback, rejectCallback]\n\n  return promise\n}\n","export function attention(client) {\n  let doc = document\n  let originTitle = false\n  let unbind = []\n  let timeout = false\n\n  let restoreTitle = () => {\n    if (originTitle) {\n      doc.title = originTitle\n      originTitle = false\n    }\n  }\n\n  let blink = () => {\n    if (doc.hidden && !originTitle) {\n      originTitle = doc.title\n      doc.title = '* ' + doc.title\n    } else {\n      restoreTitle()\n    }\n\n    if (doc.hidden) timeout = setTimeout(blink, 1000)\n  }\n\n  let tabListener = () => {\n    if (!doc.hidden && timeout) {\n      timeout = clearTimeout(timeout)\n      restoreTitle()\n    }\n  }\n\n  if (doc && typeof doc.hidden !== 'undefined') {\n    unbind.push(\n      client.node.on('error', error => {\n        if (error.type !== 'timeout' && !timeout) {\n          blink()\n        }\n      })\n    )\n\n    unbind.push(\n      client.on('add', action => {\n        if (action.type === 'logux/undo' && action.reason && !timeout) {\n          blink()\n        }\n      })\n    )\n\n    document.addEventListener('visibilitychange', tabListener, false)\n    unbind.push(() => {\n      document.removeEventListener('visibilitychange', tabListener, false)\n    })\n  }\n\n  return () => {\n    for (let i of unbind) i()\n  }\n}\n","export function favicon(client, links) {\n  let normal = links.normal\n  let offline = links.offline\n  let error = links.error\n\n  let unbind = []\n  let doc = document\n  let fav = false\n  let prevFav = false\n\n  function update() {\n    if (client.connected && prevFav !== normal) {\n      fav.href = prevFav = normal\n    } else if (\n      !client.connected &&\n      offline &&\n      prevFav !== offline &&\n      prevFav !== error\n    ) {\n      fav.href = prevFav = offline\n    }\n  }\n\n  function setError() {\n    if (error && prevFav !== error) {\n      fav.href = prevFav = error\n    }\n  }\n\n  if (doc) {\n    fav = doc.querySelector('link[rel~=\"icon\"]')\n\n    if (typeof normal === 'undefined') {\n      normal = fav ? fav.href : ''\n    }\n\n    if (!fav) {\n      fav = doc.createElement('link')\n      fav.rel = 'icon'\n      fav.href = ''\n      doc.head.appendChild(fav)\n    }\n\n    unbind.push(client.on('state', update))\n    update()\n\n    unbind.push(\n      client.on('add', action => {\n        if (action.type === 'logux/undo' && action.reason) setError()\n      })\n    )\n\n    unbind.push(\n      client.node.on('error', err => {\n        if (err.type !== 'timeout') setError()\n      })\n    )\n  }\n\n  return () => {\n    for (let i of unbind) i()\n  }\n}\n"],"names":["$457604fc98823e7c233c394ad495f88a$var$mapping","$457604fc98823e7c233c394ad495f88a$export$357eb1b4f03c1402","pairs","keys","Object","i","length","$457604fc98823e7c233c394ad495f88a$export$40339995e8a21591","id","resolved","Error","parcelRequire","register","JSON","parse","$a07098f7b88a7d1629d53c0f0d0da9c3$export$9a730a8aaf9141d1","events","[object Object]","event","args","forEach","cb","this","push","filter","$c60c7da9a4109e9736091b6952bab8a6$export$737a63ce5df84c38","emitter","action","meta","emit","type","$c60c7da9a4109e9736091b6952bab8a6$export$2b5ff101e1b2bb00","opts1","nodeId","lastTime","sequence","store","listener","on","opts","newId","generateId","time","parseInt","reasons","keepLast","removeReason","olderThan","action2","byId","addedMeta","add","now","Date","callback","order","Promise","resolve","nextPage","get","result","page","entries","entry","next","bind","diff","k","remove","k1","changeMeta","reason","criteria","$ab72e4c5e269f6d798400f37e3bac2f9$export$313f0143c6409f6","firstMeta","secondMeta","first","split","second","firstNode","secondNode","firstCounter","secondCounter","firstNodeTime","secondNodeTime","$e0aa73bb061ed71d6f9aafb5d83c2ed3$export$dd514040aada63ba","url","Class","connected","WebSocket","ws","onerror","error","onclose","onmessage","data","init","undefined","onopen","close","message","readyState","OPEN","send","stringify","err","received","$273289050e4def2546a0571a3d47e328$var$checkIndex","index","indexes","added","$273289050e4def2546a0571a3d47e328$var$forEachIndex","$273289050e4def2546a0571a3d47e328$var$isDefined","$273289050e4def2546a0571a3d47e328$var$insert","lastAdded","$273289050e4def2546a0571a3d47e328$var$eject","start","end","middle","otherAdded","splice","$273289050e4def2546a0571a3d47e328$var$find","list","value","$273289050e4def2546a0571a3d47e328$export$f84de6322139fbd6","lastReceived","lastSent","otherMeta","indexList","j","findIndex","item","created","indexed","slice","key","removed","reasonPos","indexOf","c","youngerThan","minAdded","maxAdded","removedAdded","map","m","removing","includes","sent","values","$6ae039d94f7ab2747b36aaa82b65b509$export$88909670cdf5f76b","options","supported","used","super","name","description","describe","captureStackTrace","$82c578a9349009b5095ee34cac304065$var$auth","node","token","auth","authenticated","remoteHeaders","unauthenticated","onMessage","sendError","destroy","e","$82c578a9349009b5095ee34cac304065$var$checkProtocol","ver","remoteProtocol","minProtocol","$82c578a9349009b5095ee34cac304065$var$emitEvent","$e1338eda98b983c2f73f6cfabae5dac9$var$NOT_TO_THROW","$e1338eda98b983c2f73f6cfabae5dac9$var$BEFORE_AUTH","$e1338eda98b983c2f73f6cfabae5dac9$var$syncMappedEvent","lastAddedCache","outMap","changed","sendSync","$e1338eda98b983c2f73f6cfabae5dac9$export$d24c13e903cc2330","log","connection","options1","remoteNodeId","remoteSubprotocol","localProtocol","localNodeId","ping","timeout","timeFix","syncing","state","timeouts","throwsError","unbind","onAdd","onConnecting","onConnect","disconnect","onDisconnect","initialized","initializing","initialize","localHeaders","clearTimeout","pingTimeout","endTimeout","headers","sendHeaders","msg","delayPing","setState","outFilter","ms","setTimeout","syncError","shift","sendPing","lastSynced","promises","each","then","r","catch","all","syncSinceQuery","setLastSynced","synced","getLastSynced","getLastAdded","$e1338eda98b983c2f73f6cfabae5dac9$var$DUILIANS","line","prototype","sendConnect","subprotocol","fixTime","connectSended","startTimeout","sendConnected","connectMessage","baseTime","syncSince","connectedMessage","authTime","roundTrip","Math","floor","originMeta","unshift","concat","sendSynced","syncMessage","join","process","inMap","meta2","filtered","inFilter","res","setLastReceived","syncedMessage","setLastSent","pingMessage","pongMessage","sendDebug","debugMessage","errorMessage","headersMessage","","$e0be7339bd226752908001fe3ab95cfe$var$DEFAULT_OPTIONS","$e0be7339bd226752908001fe3ab95cfe$export$85917111f6daf52d","$80ab5d1cebc30408a179f27d1c44cd4b$var$LocalConnection","pair","right","left","other","delay","$b9e23c9aad5a62431e716a1e3eff942a$var$DEFAULT_OPTIONS","minDelay","maxDelay","attempts","Infinity","$b9e23c9aad5a62431e716a1e3eff942a$var$FATAL_ERRORS","$b9e23c9aad5a62431e716a1e3eff942a$export$947a1d70f6576d50","reconnecting","connecting","reconnect","timer","visibility","document","hidden","connect","navigator","onLine","window","addEventListener","removeEventListener","nextDelay","base","rand","random","deviation","min","$000967cfece7e4885fc013b7f2a605bc$export$20998743475a6de6","parts","userId","clientId","$f05e98d011634eb9de1072eaf6bb3b6e$export$9278f117015fcf8e","client","observable","disconnected","wait","old","duration","processing","setSynchronized","changeState","sync","$33c7c2b81ee276f407f8b760b1b6260c$var$injectStyles","element","styles","style","$33c7c2b81ee276f407f8b760b1b6260c$var$RESET","boxSizing","textIndent","textTransform","wordSpacing","letterSpacing","fontStyle","fontVariant","fontWeight","lineHeight","$b71c64939dd7d21f92554fb60c5ee604$export$8cb0c0ceae301cfc","size","bytes","crypto","getRandomValues","Uint8Array","byte","toString","toUpperCase","$48c4eb20554decc7e1044c8d13ccf8bd$export$24f06e2df7fb5d4d","$8e9af09a9283a12a397c99eecfac5b87$var$ALLOWED_META","$8e9af09a9283a12a397c99eecfac5b87$var$tabPing","localStorage","setItem","prefix","tabId","$8e9af09a9283a12a397c99eecfac5b87$var$cleanTabActions","isLocalStorage","removeItem","$57d23f88e70dc6b79069ec7284a7cb1b$var$storageKey","$57d23f88e70dc6b79069ec7284a7cb1b$var$sendToTabs","json","console","role","$57d23f88e70dc6b79069ec7284a7cb1b$var$getLeader","getItem","$57d23f88e70dc6b79069ec7284a7cb1b$var$leaderPing","$57d23f88e70dc6b79069ec7284a7cb1b$var$onDeadLeader","$57d23f88e70dc6b79069ec7284a7cb1b$var$setState","$57d23f88e70dc6b79069ec7284a7cb1b$var$startElection","$57d23f88e70dc6b79069ec7284a7cb1b$var$watchForLeader","watching","$57d23f88e70dc6b79069ec7284a7cb1b$var$isActiveLeader","roleTimeout","$57d23f88e70dc6b79069ec7284a7cb1b$var$setRole","leadership","setInterval","unloading","leaderPing","elections","clearInterval","leader","leaderTimeout","electionDelay","$5b9e0f6cb671d5caf0faa29ffef52dc0$var$block","returnValue","$f21439849128c3474f28f2f6d17ce370$var$bold","string","$f21439849128c3474f28f2f6d17ce370$var$showLog","text","details","Array","from","match","_","groupCollapsed","groupEnd","$6171cae8154909f81c5d7962291cdbaf$var$bundleURL","$6171cae8154909f81c5d7962291cdbaf$var$getBaseURL","replace","$6171cae8154909f81c5d7962291cdbaf$export$da289beea9c5b10d","matches","stack","$6171cae8154909f81c5d7962291cdbaf$var$getBundleURL","$d8e73c1a0305a00754e02697844bc85c$var$dirname","_filePath","filePath","slashIndex","lastIndexOf","$d8e73c1a0305a00754e02697844bc85c$var$relative","to","fromParts","divergeIndex","toParts","apply","module","exports","fromId","toId","$d8e73c1a0305a00754e02697844bc85c$require$resolve","_dirname","_relative","$017d4be7a81227e21d7002813098a3db$exports","getBundleURL","$5395fb2231324673681f7b0c6345f98e$exports","$8b1d46243a56382797fca4c6055a574b$exports","$91a0a8252e07347eed6c69bf3b097745$exports","$087a05d37f27b7c937524b3dbf1d66b0$export$b1f1417016a70992","position","width","height","margin","paddingLeft","opacity","borderRadius","color","fontFamily","zIndex","backgroundPosition","backgroundRepeat","backgroundSize","display","verticalAlign","synchronized","backgroundColor","backgroundImage","$parcel$interopDefault","sending","protocolError","$86fff228e933126a9a7030c8b24253dd$exports","$d2782e8aaee0d9433668bbe92398f014$exports","$db5bdc44f1daf2edf4445d4483ae7e4b$exports","$92cf3332670dc04ed77c0caca38ef406$var$pair","$92cf3332670dc04ed77c0caca38ef406$var$serverLog","$92cf3332670dc04ed77c0caca38ef406$var$client","cleanPrevActions","resolveCallback","rejectCallback","promise","reject","$8fb4f6203e73088fd6397ed6a8163a2a$export$7d87069e7c83a19b","wasConnected","getClientId","onUnload","pinging","clean","tabTimeout","lastId","nextLog","resubscribe","last","subscriptions","subscribing","unsubscribing","unsubscription","subscribers","subscription","channel","channels","tabPing","server","async","test","allowDangerousProtocol","unbindEnvTest","env","since","leaderState","onStorage","changeUser","newValue","tab","isArray","compare","leftParts","rightParts","leftNumber","rightNumber","$57d23f88e70dc6b79069ec7284a7cb1b$var$compareSubprotocols","subprotocolKey","location","hash","$92cf3332670dc04ed77c0caca38ef406$var$node","doc","originTitle","restoreTitle","title","blink","tabListener","$66ee27a082d6d6a50f62bc69814bf47b$export$197f306872c183c7","update","$5b9e0f6cb671d5caf0faa29ffef52dc0$export$23cbf8a279e68c13","links","normal","offline","fav","prevFav","href","setError","querySelector","createElement","rel","head","appendChild","$4d572e45e76909da5e95386516660d7c$export$a03ba23e48ff78c","messages","widget","setAttribute","top","transform","pos","$33c7c2b81ee276f407f8b760b1b6260c$var$setPosition","show","innerHTML","denied","body","$33c7c2b81ee276f407f8b760b1b6260c$export$14b35de56dab357d","prevConnected","cleaned","ignore","ignoreActions","reduce","Action","processed","Meta","From","user","startsWith","$f21439849128c3474f28f2f6d17ce370$export$80d2cc7bee77574a","s","status","innerText","$92cf3332670dc04ed77c0caca38ef406$var$count","$92cf3332670dc04ed77c0caca38ef406$var$updateTitle","checked","disabled","isLeader","onchange","target","onclick","serverError","subprotocolError","subprotocolClient","open"],"version":3,"file":"index.89847aa1.js.map"}